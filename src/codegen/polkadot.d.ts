import { StorageDescriptor, PlainDescriptor, AssetDescriptor, TxDescriptor, RuntimeDescriptor, Enum, QueryFromDescriptors, TxFromDescriptors, EventsFromDescriptors, ErrorsFromDescriptors, ConstFromDescriptors, SS58String, Binary } from "@polkadot-api/client";
import { I5sesotjlssv2d, Iffmde3ekjedi9, Idin6nhq46lvdj, Iav1fkj39ai0lr, Iep4uo61810hfs, Ieniouoqkq4icf, Phase, Iddofueil04dld, I5g2vv0ckl2m8b, PreimageRequestStatus, PreimageRequestStatus1, I64gm4hrq7urum, I2qinct8jq4bqe, BabeDigestsNextConfigDescriptor, Idhnf6rtqoslea, I5o0h2ngv65fpq, I17k3ujudqd5df, Idkva8q2m9meg0, Ifip05kcrl65am, Iff9heri56m1mb, I1q8tnt1cluu5j, Ibtifm27unhnjf, Iactubn52acokl, I233put12fltor, Icqu54ik1fbovu, TransactionPaymentReleases, Ia2lhg7l2hilo3, I21nedsp35hoih, StakingRewardDestination, I9o7ssi9vmhmgr, Ic3m9d6tdl6gi2, Ib3j7gb0jgs38u, Ifekshcrgkl12g, I7svnfko10tq2e, Iff9p3c7k6pfoi, StakingForcing, Iafq6t4rgheait, I4ojmnsk1dchql, Iinkhfdlka9ch, I2kj4j6mp68hf8, I6ouflveob4eli, Ia9ek8s49lerat, I2bqvqrg0sbrdj, Iasase33a12046, I6gic9mme18mpd, Icgljjb6j82uhn, I4g61cdhi06s1m, Idhk5e7nto8mrb, GrandpaStoredState, Ibu50q5vhsfq5e, Iegmj7n48sc3am, Ie05qfg5feue1l, ConvictionVotingVoteVoting, If9jidduiuq7vv, ReferendaTypesReferendumInfo, I2phecamkn3pej, ClaimsStatementKind, Ifble4juuml5ig, VestingReleases, I60cr97f9of5s5, Ib22937a5d3pt0, I4nfjdef0ibh44, I74af64m08r6as, If0n3k77qd4p7k, I3tjio59962rg2, Iag146hmjgqfgj, I73gble6tmb52f, Ic28sp53lp2v4a, Idvn49j11itec9, ElectionProviderMultiPhasePhase, Ia5nfh4hon3go3, Ia7o65280hur3p, Iasd2iat48n080, Ic8d01sg6acf60, Irl37q7erstrb, I8s6n43okuj2b1, Ic5t26f9cp3tvk, I39k39h6vu4hbq, Idphjddn2h69vc, I13ttsmlfr8g52, If6qa32dj75gu1, I7oo2mprv1qd1s, NominationPoolsClaimPermission, I2eh80qovrl7h2, Ia2hpj72knb2q9, Ies9ffs3ho1o06, I663ddds93n8hc, I78e99376i3249, Ic4ms979ng98e4, Ic1d4u2opv3fst, I3qttgoifdk5v6, Iarlj3qd8u1v13, In9ekmba4m5ft, Ievsccbpmuhatk, Iaja1oeag5u4b3, ParachainsParasParaLifecycle, I79cs1p3m59mo7, PolkadotPrimitivesV5UpgradeGoAhead, PolkadotPrimitivesV5UpgradeRestriction, I2duhnt686rv0q, I14hoekog5s49k, I6ljjd4b5fa4ov, Ibhmrlkcu01imb, I50mrcbubp554e, Id43g4eveajpkl, I6u4labiv1bntm, Iev3u09i2vqn93, I9olhgo2o08h7b, I7k9oi9p83j43l, I6sbufrhmgqdb6, I87u7jalc0lhah, If89923vhoiaim, I4arjljr6dpflb, I3g2jv3qmtkrbe, I3av628q6dt6mq, Ifmaahl40gom3g, I70iuri2ilha1f, I2neqklu8gtd27, XcmPalletQueryStatus, I46ggargfeekkj, I7vlvrrl2pnbgk, Ibdqc639q3ofe0, XcmPalletVersionMigrationStage, Iaaeqd8puo95gs, I61vn4ct4e1jjd, I64u7pb324isgb, Ic9ppo8st33eqb, ParachainsInclusionAggregateMessageOrigin, I53esa2ms463bk, Ibg270mmpf1f2q, I32r9skkupsthv, Ie5mvl0hn85mkc, I3qm5u05tioq05, In7a38730s6qs, If15el53dd76v9, I9s0ave7t0vnrk, Ib5fo0fakl8rog, I4q39t5hn830vp, I35p85j063s0il, Ibafpkl9hhno69, Iafqnechp3omqg, Iasb8k6ash5mjn, I8ofcg5rbj0g2c, I4adgbll7gku4i, I6pjjpfvhvcfru, I8qrhskdehbu57, I39uah9nss64h9, Ik64dknsq7k08, I3qt1iclgnlpc3, I5n4sebgkfr760, Ie7cb775si1ku8, Idsdstalforb09, I6rb3dbq8mv545, I90bto8860mivd, I82nfqfkd48n10, Id9d48vaes3c53, Idaor7tajt0l3k, I7mmbgd20nut80, I2dcpbss9027dl, Idcr6u6361oad9, I666bl2fqjkejo, Idge7gk9m5car0, I34pbimt2i69v7, Ien6q0lasi0m7i, Icacgruoo9j3r2, I7dgmo7im9hljo, Iargojp1sv9icj, Ibmr18suc9ikh9, Ie0io91hk7pejj, I9f7ms9viml8of, I564va64vtidbq, Ie5v6njpckr05b, I328av3j0bgmjb, I4tuqm9ato907i, I5n9nf1mhg26dt, Ida5hg7geddnc7, I3vh014cqgmrfd, Ifhs60omlhvt3, If34udpd5e57vi, I39t01nnod9109, Ie5vbnd9198quk, I3h6murn8bd4v5, I6k6jf8ncesuu3, I2j5nkj9u94qun, I9nfsuc9smbmvv, I3v6ks33uluhnj, I5ont0141q9ss5, Ifu2fv3jk8vbos, I4kjek1q6rj24q, I2hviml3snvhhn, Ifgbq9oil78ogk, I5c883qnnqciv8, Icm9m0qeemu66d, Idpn74s0i9cdvp, I815t7ta25e227, Idnsr2pndm36h0, Id7ut33dljf52c, I8steo882k7qns, I1vc8h4t228bot, I5f178ab6b89t3, I5fak1u82ohqtm, I86t0cca08a1h1, Icbio0e1f0034b, Ifml0k0sf0mu2g, I8413rb6im3iko, Id3s9pakjjc472, Idf7eras2rn4rj, I1u3s4gbjnre15, I20qiajmn4c5d4, Ie3aplba76d794, I1ntko0oih7v1a, I193pigt6gtjff, I29er5j74l8bu, I9l9kkok4o3ekh, I50ve0bbda0j1r, Ict9ivhr2c5hv0, Id8ilk50mukg0o, Ie36meht90lrma, Ibb7qiar2nh5rh, I6c37kkkbmesra, Ibsu2pfvipmui6, I621gpns74tp1f, I5100vdjbepcoj, I9l2s4klu0831o, I2ctrt5nqb8o7c, I711qahikocb1c, Id6gojh30v9ib2, I2g5s5rvm0mfuf, Iclf5v4qsadc12, Ifcc5t6ed1elfd, I55q6ritdd2v83, Iaaog12m0bl04j, I6l2ag419uso4i, I7304brn0jssvr, Id3bpmvju2iqi5, Ietdab69eu3c4e, Ic91pvvaf9eh9k, I9qeq6jurh88f2, I8aql6ho3v5akd, I349bg0i7n8ohu, I8plicv234mqe5, I2a839vbf5817q, Ia9p5bg6p18r0i, I86gbm3avnuhcj, I9khudebied2et, I90n6nnkpdahrh, I8mk5kjgn02hi8, I113qogfj9ii7a, I2gr10p66od9ch, I6okbrc1o6b331, I31k9f0jol8ko4, I80q14um2s2ckg, I5qs1t1erfi7u8, I9et13knvdvgpb, Ifsme8miqq9006, Iqk00vc9d6173, Idg844jjtqnc9b, Ic87kbtabpr82b, Ieg1oc56mamrl5, Ifi2b6p41bfb97, Itveli0chegtk, I36uoc8t9liv80, I1u21ookp1djj3, If5k9orpn9fi43, I1hlpf8ergrg8k, I47a2tsd2o2b1c, Ibat0jog71khv5, I4ihj26hl75e5p, I2rqmn40aam5hg, I3cvu4kn8n81uv, I931cottvong90, I6l7t90ftdbsr6, Icbgkt7i4ps8kc, I40s11r8nagn2g, I6bjj87fr5g9nl, I8cbluptqo8kbp, I81cc4plffa1dm, I9j0ul7nh7b8jv, Id581arok0b1nj, I9jsikd1ghmc7l, I2f6mha3v4ooda, Iasqjdhasi408s, Iehb5cb6rp4k2p, I6uj8ujct0o4v7, I1k3urvkqqshbc, I2ff0ffsh15vej, I1orfg86bkg123, Iaus4cb3drhu9q, Ivnsat10lv9d6, Ifqm1da2k7es4d, I4aouqiv2fh67c, I9tmok5kceg2bg, I85icj2qbjeqbe, Ibuhbp68e6tkct, Idrevppfiubhve, I9s2h36kr71vk9, I4lkbiubo9ogq9, Id1baei7m8gkhk, I96ftepqm4vs7m, Ic3430470j4mbv, I1ur1874hp9ar5, I7mf0sij342109, Ibvirp862qkkup, Ic5b47dj4coa3r, Idehabrqi23sc0, Idfpo6162k0hq, I19hvnphoaj44l, I1ng31ej27mh4k, I3js6c9fubdele, I6n5jj22t7mm7i, Ia1u3jll6a06ae, I7cl9esn1l72m7, I3k27o64k49es2, Icvpjofp09bmlh, Ieeis6pj62kiu4, I53e0mdinhcvpm, I732o5n04n5ohg, Ic76kfh5ebqkpl, I3pog27ittgi9g, Ifcceq8taolrca, Ibgm4rnf22lal1, I3f1tq7m3kurig, Ifhnflnkf9f278, I16soggnee6qrb, Ifvnf1s3g2lg8u, I894urueu7skf3, Iemqna2uucuei9, Iede1ukavoderd, Iennefu6o2bgdm, Icbccs0ug47ilf, Ieob37pbjnvmkj, Idv8erd9m7jvse, Ibkv7dijodoblp, Icv68aq8841478, Ic262ibdoec56a, Iflcfm9b6nlmdd, Ijrsf4mnp3eka, Id5fm4p8lj5qgi, Idm5rqp3duosod, I4cbvqmqadhrea, I3qt1hgg4djhgb, Ier2cke86dqbr2, I1au3fq4n84nv3, I5j22i27djc5r4, Idnak900lt5lm8, I27n7lbd66730p, I2hq50pu2kdjpo, Ifk8eme5o7mukf, Iau4cgm6ih61cf, Idl3umm12u5pa, I6ir616rur362k, Ic19as7nbst738, I54umskavgc9du, I43l31t29k2o0p, I41n4hddrgegvb, Ib31jedabim0q7, I93nne97c4i0sr, I311vp8270bfmr, I44hc4lgsn4o1j, I8iksqi3eani0a, I16enopmju1p0q, Ifgqhle2413de7, I43kq8qudg7pq9, I76riseemre533, I38bmcrmh852rk, I4hcillge8de5f, Iblqf6usek6oij, Iek7v4hrgnq6iv, Ic5oktqtdlvdvq, Idhr9v8mlnjej, I62nte77gksm0f, I932allgc83a4a, Ilhp45uime5tp, I50aq0q2l1cdkr, I7b8pe56shlide, Idhjiuhlaei3db, Ievr89968437gm, I6tn8e5lqr339o, I11lb9o37qkk4f, Ie5i8qqljk3tjb, Iep1lmt6q3s6r3, I1fac16213rie2, Ifjt77oc391o43, Itvt1jsipv0lc, Ick3mveut33f44, I180p9c978rp4d, Idbjbboh0q507r, I94ud6o1n6v0n8, Ibvv58de7m7rsi, I4uo2dg1jvbdtg, Ifbo6gts4g8u33, I82jp3a00f0f8k, Id9idaj83175f9, Ie1semicfuv5uu, If25fjs9o37co1, I70sc1pdo8vtos, I60p8l86a8cm59, I3m3sk2lgcabvp, I5pf572duh4oeg, I5an5igf3n0vgh, I1rd7gkt317ndg, I7j4m7a3pkvsf4, Icrg5eih8vnokr, I37454vatvmm1l, Iblau1qa7u7fet, I1ti389kf8t6oi, If4nnre373amul, I55kbor0ocqk6h, Idsj9cg7j96kpc, Ido4u9drncfaml, I2inhcpqb4h0bg, I7vqogd77mmdlm, I6mik29s5073td, I2m0sqmb75cnpb, I49agc5b62mehu, Iatq9jda4hq6pg, I2g87evcjlgmqi, Iag2vtju06tj0k, Ic0he9tlf9ll0u, Ieno5vn1m65ng2, Ievbvtucck5gnq, Ic8i89mfkmn3n7, Id2bej717ckub0, I545vo2e86o5i4, I3o099fcusuh31, Ifr2e7vm3bun8k, Ibs22tt76qp5bi, I37r4bdai8o9mp, Idn2ghub1o4i40, I48u78djt89dod, Ib85m5kfbepu2t, Idaml5bdhsfcsl, Ieec0cu336gteb, I815d5k4ij85nv, Ifi98fgi9o46v7, Ic0oj9tok33uap, I3tdutpfjuk32j, I1esdujrkdacpb, I9g1d820jf9m2s, I8ve4g3egaln6a, If9e3ujpsfl4g7, If4hvqaeoqq5us, I4e7dkr4hrus3u, Ia5b8kts5gt3p5, Ise9r0vrat2m6, I7kkbgm2llu2o3, I2uqmls7kcdnii, Idg69klialbkb8, I9j133okge3c2, I30pg328m00nr3, I5qm1bvb2j3ap2, I95aqmsd6gjmqs, Iarlf7ddo81fm5, Ie9bjgclf7vho0, I7dm0nb8u3g2hv, I5pnf8l8c1nkfk, Ibknqphki4flb3, I6ian27okrbc15, I74b8cu68dfbfr, Iacc6dee8ffsrh, Ielsom2b1kkdm6, Iedcb9b2srjfp0, BagsListListListError, NominationPoolsPalletDefensiveError, Ia4jqf401148a4, I6t1nedlt7mobn, Iabpgqcjikia83, I132412t2eshc6, If39abi8floaaf, Itom7fk49o0c9, Ibcdj0j79gq1uo, TransactionValidityTransactionSource, I6d9lhhdri071p, I5985kfq7sspta, I8a7gsn4nh0gne, PolkadotPrimitivesV5OccupiedCoreAssumption, I3gq2gui038qt, Ic7as9gfl5utn9, I2914et6njplkd, Ianqtalutublq5, I2pf0b05mc7sdr, Ibfq7qcjfd788c, I5537sfe0t0708, I3h1ccufdk38ej, I8bqhj6psoqsin, I1b0210m3f090j, Icqsglphsrpv5, Iag14tqe65tvpf, I4gc64ora0pbbf, Iavuvfkop6318c, I71rr2d0kb0iu3, I6lgkrki6lhal, I7m8g2583l7nbe, I256gkugrgtccq, I32e5ntud5fl8i, I2ij509mgq3dve, I9lnenfklcdre, I95fr9lj1pb8v8, Iap4lrotpgmqpv, I6sbl80o3jmgfd, I7bek4s9acs8nl, I96ok5o1k21bpi, I5r4utvvlnltpd, Iei2mvq0mjvt81, I8e6un4uk1q07c, I9q9lvv0h98nhk } from "./common-types";
type AnonymousEnum<T extends {}> = T & {
    __anonymous: true;
};
type IEnum<T extends {}> = Enum<{
    [K in keyof T & string]: {
        type: K;
        value: T[K];
    };
}[keyof T & string]>;
type MyTuple<T> = [T, ...T[]];
type SeparateUndefined<T> = undefined extends T ? undefined | Exclude<T, undefined> : T;
type Anonymize<T> = SeparateUndefined<T extends string | number | bigint | boolean | void | undefined | null | symbol | Binary | Uint8Array | Enum<{
    type: string;
    value: any;
}> ? T : T extends AnonymousEnum<infer V> ? IEnum<V> : T extends MyTuple<any> ? {
    [K in keyof T]: T[K];
} : T extends [] ? [] : T extends Array<infer A> ? Array<A> : {
    [K in keyof T & string]: T[K];
}>;
type IPallets = {
    System: [
        {
            /**
             * The full account information for a particular account ID.
             */
            Account: StorageDescriptor<[Key: SS58String], Anonymize<I5sesotjlssv2d>, false>;
            /**
             * Total extrinsics count for the current block.
             */
            ExtrinsicCount: StorageDescriptor<[], number, true>;
            /**
             * The current weight for the block.
             */
            BlockWeight: StorageDescriptor<[], Anonymize<Iffmde3ekjedi9>, false>;
            /**
             * Total length (in bytes) for all extrinsics put together, for the current block.
             */
            AllExtrinsicsLen: StorageDescriptor<[], number, true>;
            /**
             * Map of block numbers to block hashes.
             */
            BlockHash: StorageDescriptor<[Key: number], Binary, false>;
            /**
             * Extrinsics data for the current block (maps an extrinsic's index to its data).
             */
            ExtrinsicData: StorageDescriptor<[Key: number], Binary, false>;
            /**
             * The current block number being processed. Set by `execute_block`.
             */
            Number: StorageDescriptor<[], number, false>;
            /**
             * Hash of the previous block.
             */
            ParentHash: StorageDescriptor<[], Binary, false>;
            /**
             * Digest of the current block, also part of the block header.
             */
            Digest: StorageDescriptor<[], Anonymize<Idin6nhq46lvdj>, false>;
            /**
             * Events deposited for the current block.
             *
             * NOTE: The item is unbound and should therefore never be read on chain.
             * It could otherwise inflate the PoV size of a block.
             *
             * Events have a large in-memory size. Box the events to not go out-of-memory
             * just in case someone still reads them from within the runtime.
             */
            Events: StorageDescriptor<[], Anonymize<Iav1fkj39ai0lr>, false>;
            /**
             * The number of events in the `Events<T>` list.
             */
            EventCount: StorageDescriptor<[], number, false>;
            /**
             * Mapping between a topic (represented by T::Hash) and a vector of indexes
             * of events in the `<Events<T>>` list.
             *
             * All topic vectors have deterministic storage locations depending on the topic. This
             * allows light-clients to leverage the changes trie storage tracking mechanism and
             * in case of changes fetch the list of events of interest.
             *
             * The value has the type `(BlockNumberFor<T>, EventIndex)` because if we used only just
             * the `EventIndex` then in case if the topic has the same contents on the next block
             * no notification will be triggered thus the event might be lost.
             */
            EventTopics: StorageDescriptor<[Key: Binary], Anonymize<Iep4uo61810hfs>, false>;
            /**
             * Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened.
             */
            LastRuntimeUpgrade: StorageDescriptor<[], Anonymize<Ieniouoqkq4icf>, true>;
            /**
             * True if we have upgraded so that `type RefCount` is `u32`. False (default) if not.
             */
            UpgradedToU32RefCount: StorageDescriptor<[], boolean, false>;
            /**
             * True if we have upgraded so that AccountInfo contains three types of `RefCount`. False
             * (default) if not.
             */
            UpgradedToTripleRefCount: StorageDescriptor<[], boolean, false>;
            /**
             * The execution phase of the block.
             */
            ExecutionPhase: StorageDescriptor<[], Phase, true>;
        },
        {
            /**
             *See [`Pallet::remark`].
             */
            remark: TxDescriptor<Anonymize<I8ofcg5rbj0g2c>>;
            /**
             *See [`Pallet::set_heap_pages`].
             */
            set_heap_pages: TxDescriptor<Anonymize<I4adgbll7gku4i>>;
            /**
             *See [`Pallet::set_code`].
             */
            set_code: TxDescriptor<Anonymize<I6pjjpfvhvcfru>>;
            /**
             *See [`Pallet::set_code_without_checks`].
             */
            set_code_without_checks: TxDescriptor<Anonymize<I6pjjpfvhvcfru>>;
            /**
             *See [`Pallet::set_storage`].
             */
            set_storage: TxDescriptor<Anonymize<I8qrhskdehbu57>>;
            /**
             *See [`Pallet::kill_storage`].
             */
            kill_storage: TxDescriptor<Anonymize<I39uah9nss64h9>>;
            /**
             *See [`Pallet::kill_prefix`].
             */
            kill_prefix: TxDescriptor<Anonymize<Ik64dknsq7k08>>;
            /**
             *See [`Pallet::remark_with_event`].
             */
            remark_with_event: TxDescriptor<Anonymize<I8ofcg5rbj0g2c>>;
        },
        {
            /**
             *An extrinsic completed successfully.
             */
            ExtrinsicSuccess: PlainDescriptor<Anonymize<Iede1ukavoderd>>;
            /**
             *An extrinsic failed.
             */
            ExtrinsicFailed: PlainDescriptor<Anonymize<Iennefu6o2bgdm>>;
            /**
             *`:code` was updated.
             */
            CodeUpdated: PlainDescriptor<undefined>;
            /**
             *A new account was created.
             */
            NewAccount: PlainDescriptor<Anonymize<Icbccs0ug47ilf>>;
            /**
             *An account was reaped.
             */
            KilledAccount: PlainDescriptor<Anonymize<Icbccs0ug47ilf>>;
            /**
             *On on-chain remark happened.
             */
            Remarked: PlainDescriptor<Anonymize<Ieob37pbjnvmkj>>;
        },
        {
            /**
             *The name of specification does not match between the current runtime
             *and the new runtime.
             */
            InvalidSpecName: PlainDescriptor<undefined>;
            /**
             *The specification version is not allowed to decrease between the current runtime
             *and the new runtime.
             */
            SpecVersionNeedsToIncrease: PlainDescriptor<undefined>;
            /**
             *Failed to extract the runtime version from the new runtime.
             *
             *Either calling `Core_version` or decoding `RuntimeVersion` failed.
             */
            FailedToExtractRuntimeVersion: PlainDescriptor<undefined>;
            /**
             *Suicide called when the account has non-default composite data.
             */
            NonDefaultComposite: PlainDescriptor<undefined>;
            /**
             *There is a non-zero reference count preventing the account from being purged.
             */
            NonZeroRefCount: PlainDescriptor<undefined>;
            /**
             *The origin filter prevent the call to be dispatched.
             */
            CallFiltered: PlainDescriptor<undefined>;
        },
        {
            /**
             * Block & extrinsics weights: base values and limits.
             */
            BlockWeights: PlainDescriptor<Anonymize<In7a38730s6qs>>;
            /**
             * The maximum length of a block (in bytes).
             */
            BlockLength: PlainDescriptor<Anonymize<If15el53dd76v9>>;
            /**
             * Maximum number of block number to block hash mappings to keep (oldest pruned first).
             */
            BlockHashCount: PlainDescriptor<number>;
            /**
             * The weight of runtime database operations the runtime can invoke.
             */
            DbWeight: PlainDescriptor<Anonymize<I9s0ave7t0vnrk>>;
            /**
             * Get the chain's current version.
             */
            Version: PlainDescriptor<Anonymize<Ib5fo0fakl8rog>>;
            /**
             * The designated SS58 prefix of this chain.
             *
             * This replaces the "ss58Format" property declared in the chain spec. Reason is
             * that the runtime should know about the prefix in order to make use of it as
             * an identifier of the chain.
             */
            SS58Prefix: PlainDescriptor<number>;
        }
    ];
    Scheduler: [
        {
            /**
            
             */
            IncompleteSince: StorageDescriptor<[], number, true>;
            /**
             * Items to be executed, indexed by the block number that they should be executed on.
             */
            Agenda: StorageDescriptor<[Key: number], Anonymize<Iddofueil04dld>, false>;
            /**
             * Lookup from a name to the block number and index of the task.
             *
             * For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4
             * identities.
             */
            Lookup: StorageDescriptor<[Key: Binary], Anonymize<I5g2vv0ckl2m8b>, true>;
        },
        {
            /**
             *See [`Pallet::schedule`].
             */
            schedule: TxDescriptor<Anonymize<I3qt1iclgnlpc3>>;
            /**
             *See [`Pallet::cancel`].
             */
            cancel: TxDescriptor<Anonymize<I5n4sebgkfr760>>;
            /**
             *See [`Pallet::schedule_named`].
             */
            schedule_named: TxDescriptor<Anonymize<Ie7cb775si1ku8>>;
            /**
             *See [`Pallet::cancel_named`].
             */
            cancel_named: TxDescriptor<Anonymize<Idsdstalforb09>>;
            /**
             *See [`Pallet::schedule_after`].
             */
            schedule_after: TxDescriptor<Anonymize<I6rb3dbq8mv545>>;
            /**
             *See [`Pallet::schedule_named_after`].
             */
            schedule_named_after: TxDescriptor<Anonymize<I90bto8860mivd>>;
        },
        {
            /**
             *Scheduled some task.
             */
            Scheduled: PlainDescriptor<Anonymize<I5n4sebgkfr760>>;
            /**
             *Canceled some task.
             */
            Canceled: PlainDescriptor<Anonymize<I5n4sebgkfr760>>;
            /**
             *Dispatched some task.
             */
            Dispatched: PlainDescriptor<Anonymize<Idv8erd9m7jvse>>;
            /**
             *The call for the provided hash was not found so the task has been aborted.
             */
            CallUnavailable: PlainDescriptor<Anonymize<Ibkv7dijodoblp>>;
            /**
             *The given task was unable to be renewed since the agenda is full at that block.
             */
            PeriodicFailed: PlainDescriptor<Anonymize<Ibkv7dijodoblp>>;
            /**
             *The given task can never be executed since it is overweight.
             */
            PermanentlyOverweight: PlainDescriptor<Anonymize<Ibkv7dijodoblp>>;
        },
        {
            /**
             *Failed to schedule a call
             */
            FailedToSchedule: PlainDescriptor<undefined>;
            /**
             *Cannot find the scheduled call.
             */
            NotFound: PlainDescriptor<undefined>;
            /**
             *Given target block number is in the past.
             */
            TargetBlockNumberInPast: PlainDescriptor<undefined>;
            /**
             *Reschedule failed because it does not change scheduled time.
             */
            RescheduleNoChange: PlainDescriptor<undefined>;
            /**
             *Attempt to use a non-named function on a named task.
             */
            Named: PlainDescriptor<undefined>;
        },
        {
            /**
             * The maximum weight that may be scheduled per block for any dispatchables.
             */
            MaximumWeight: PlainDescriptor<Anonymize<I4q39t5hn830vp>>;
            /**
             * The maximum number of scheduled calls in the queue for a single block.
             *
             * NOTE:
             * + Dependent pallets' benchmarks might require a higher limit for the setting. Set a
             * higher limit under `runtime-benchmarks` feature.
             */
            MaxScheduledPerBlock: PlainDescriptor<number>;
        }
    ];
    Preimage: [
        {
            /**
             * The request status of a given hash.
             */
            StatusFor: StorageDescriptor<[Key: Binary], PreimageRequestStatus, true>;
            /**
             * The request status of a given hash.
             */
            RequestStatusFor: StorageDescriptor<[Key: Binary], PreimageRequestStatus1, true>;
            /**
            
             */
            PreimageFor: StorageDescriptor<[Key: Anonymize<I64gm4hrq7urum>], Binary, true>;
        },
        {
            /**
             *See [`Pallet::note_preimage`].
             */
            note_preimage: TxDescriptor<Anonymize<I82nfqfkd48n10>>;
            /**
             *See [`Pallet::unnote_preimage`].
             */
            unnote_preimage: TxDescriptor<Anonymize<Id9d48vaes3c53>>;
            /**
             *See [`Pallet::request_preimage`].
             */
            request_preimage: TxDescriptor<Anonymize<Id9d48vaes3c53>>;
            /**
             *See [`Pallet::unrequest_preimage`].
             */
            unrequest_preimage: TxDescriptor<Anonymize<Id9d48vaes3c53>>;
            /**
             *See [`Pallet::ensure_updated`].
             */
            ensure_updated: TxDescriptor<Anonymize<Idaor7tajt0l3k>>;
        },
        {
            /**
             *A preimage has been noted.
             */
            Noted: PlainDescriptor<Anonymize<Id9d48vaes3c53>>;
            /**
             *A preimage has been requested.
             */
            Requested: PlainDescriptor<Anonymize<Id9d48vaes3c53>>;
            /**
             *A preimage has ben cleared.
             */
            Cleared: PlainDescriptor<Anonymize<Id9d48vaes3c53>>;
        },
        {
            /**
             *Preimage is too large to store on-chain.
             */
            TooBig: PlainDescriptor<undefined>;
            /**
             *Preimage has already been noted on-chain.
             */
            AlreadyNoted: PlainDescriptor<undefined>;
            /**
             *The user is not authorized to perform this action.
             */
            NotAuthorized: PlainDescriptor<undefined>;
            /**
             *The preimage cannot be removed since it has not yet been noted.
             */
            NotNoted: PlainDescriptor<undefined>;
            /**
             *A preimage may not be removed when there are outstanding requests.
             */
            Requested: PlainDescriptor<undefined>;
            /**
             *The preimage request cannot be removed since no outstanding requests exist.
             */
            NotRequested: PlainDescriptor<undefined>;
            /**
             *More than `MAX_HASH_UPGRADE_BULK_COUNT` hashes were requested to be upgraded at once.
             */
            TooMany: PlainDescriptor<undefined>;
            /**
             *Too few hashes were requested to be upgraded (i.e. zero).
             */
            TooFew: PlainDescriptor<undefined>;
        },
        {}
    ];
    Babe: [
        {
            /**
             * Current epoch index.
             */
            EpochIndex: StorageDescriptor<[], bigint, false>;
            /**
             * Current epoch authorities.
             */
            Authorities: StorageDescriptor<[], Anonymize<I2qinct8jq4bqe>, false>;
            /**
             * The slot at which the first epoch actually started. This is 0
             * until the first block of the chain.
             */
            GenesisSlot: StorageDescriptor<[], bigint, false>;
            /**
             * Current slot number.
             */
            CurrentSlot: StorageDescriptor<[], bigint, false>;
            /**
             * The epoch randomness for the *current* epoch.
             *
             * # Security
             *
             * This MUST NOT be used for gambling, as it can be influenced by a
             * malicious validator in the short term. It MAY be used in many
             * cryptographic protocols, however, so long as one remembers that this
             * (like everything else on-chain) it is public. For example, it can be
             * used where a number is needed that cannot have been chosen by an
             * adversary, for purposes such as public-coin zero-knowledge proofs.
             */
            Randomness: StorageDescriptor<[], Binary, false>;
            /**
             * Pending epoch configuration change that will be applied when the next epoch is enacted.
             */
            PendingEpochConfigChange: StorageDescriptor<[], BabeDigestsNextConfigDescriptor, true>;
            /**
             * Next epoch randomness.
             */
            NextRandomness: StorageDescriptor<[], Binary, false>;
            /**
             * Next epoch authorities.
             */
            NextAuthorities: StorageDescriptor<[], Anonymize<I2qinct8jq4bqe>, false>;
            /**
             * Randomness under construction.
             *
             * We make a trade-off between storage accesses and list length.
             * We store the under-construction randomness in segments of up to
             * `UNDER_CONSTRUCTION_SEGMENT_LENGTH`.
             *
             * Once a segment reaches this length, we begin the next one.
             * We reset all segments and return to `0` at the beginning of every
             * epoch.
             */
            SegmentIndex: StorageDescriptor<[], number, false>;
            /**
             * TWOX-NOTE: `SegmentIndex` is an increasing integer, so this is okay.
             */
            UnderConstruction: StorageDescriptor<[Key: number], Anonymize<Idhnf6rtqoslea>, false>;
            /**
             * Temporary value (cleared at block finalization) which is `Some`
             * if per-block initialization has already been called for current block.
             */
            Initialized: StorageDescriptor<[], Anonymize<I5o0h2ngv65fpq>, true>;
            /**
             * This field should always be populated during block processing unless
             * secondary plain slots are enabled (which don't contain a VRF output).
             *
             * It is set in `on_finalize`, before it will contain the value from the last block.
             */
            AuthorVrfRandomness: StorageDescriptor<[], Anonymize<I17k3ujudqd5df>, false>;
            /**
             * The block numbers when the last and current epoch have started, respectively `N-1` and
             * `N`.
             * NOTE: We track this is in order to annotate the block number when a given pool of
             * entropy was fixed (i.e. it was known to chain observers). Since epochs are defined in
             * slots, which may be skipped, the block numbers may not line up with the slot numbers.
             */
            EpochStart: StorageDescriptor<[], Anonymize<I5g2vv0ckl2m8b>, false>;
            /**
             * How late the current block is compared to its parent.
             *
             * This entry is populated as part of block execution and is cleaned up
             * on block finalization. Querying this storage entry outside of block
             * execution context should always yield zero.
             */
            Lateness: StorageDescriptor<[], number, false>;
            /**
             * The configuration for the current epoch. Should never be `None` as it is initialized in
             * genesis.
             */
            EpochConfig: StorageDescriptor<[], Anonymize<Idkva8q2m9meg0>, true>;
            /**
             * The configuration for the next epoch, `None` if the config will not change
             * (you can fallback to `EpochConfig` instead in that case).
             */
            NextEpochConfig: StorageDescriptor<[], Anonymize<Idkva8q2m9meg0>, true>;
            /**
             * A list of the last 100 skipped epochs and the corresponding session index
             * when the epoch was skipped.
             *
             * This is only used for validating equivocation proofs. An equivocation proof
             * must contains a key-ownership proof for a given session, therefore we need a
             * way to tie together sessions and epoch indices, i.e. we need to validate that
             * a validator was the owner of a given key on a given session, and what the
             * active epoch index was during that session.
             */
            SkippedEpochs: StorageDescriptor<[], Anonymize<Ifip05kcrl65am>, false>;
        },
        {
            /**
             *See [`Pallet::report_equivocation`].
             */
            report_equivocation: TxDescriptor<Anonymize<I7mmbgd20nut80>>;
            /**
             *See [`Pallet::report_equivocation_unsigned`].
             */
            report_equivocation_unsigned: TxDescriptor<Anonymize<I7mmbgd20nut80>>;
            /**
             *See [`Pallet::plan_config_change`].
             */
            plan_config_change: TxDescriptor<Anonymize<I2dcpbss9027dl>>;
        },
        {},
        {
            /**
             *An equivocation proof provided as part of an equivocation report is invalid.
             */
            InvalidEquivocationProof: PlainDescriptor<undefined>;
            /**
             *A key ownership proof provided as part of an equivocation report is invalid.
             */
            InvalidKeyOwnershipProof: PlainDescriptor<undefined>;
            /**
             *A given equivocation report is valid but already previously reported.
             */
            DuplicateOffenceReport: PlainDescriptor<undefined>;
            /**
             *Submitted configuration is invalid.
             */
            InvalidConfiguration: PlainDescriptor<undefined>;
        },
        {
            /**
             * The amount of time, in slots, that each epoch should last.
             * NOTE: Currently it is not possible to change the epoch duration after
             * the chain has started. Attempting to do so will brick block production.
             */
            EpochDuration: PlainDescriptor<bigint>;
            /**
             * The expected average block time at which BABE should be creating
             * blocks. Since BABE is probabilistic it is not trivial to figure out
             * what the expected average block time should be based on the slot
             * duration and the security parameter `c` (where `1 - c` represents
             * the probability of a slot being empty).
             */
            ExpectedBlockTime: PlainDescriptor<bigint>;
            /**
             * Max number of authorities allowed
             */
            MaxAuthorities: PlainDescriptor<number>;
            /**
             * The maximum number of nominators for each validator.
             */
            MaxNominators: PlainDescriptor<number>;
        }
    ];
    Timestamp: [
        {
            /**
             * The current time for the current block.
             */
            Now: StorageDescriptor<[], bigint, false>;
            /**
             * Whether the timestamp has been updated in this block.
             *
             * This value is updated to `true` upon successful submission of a timestamp by a node.
             * It is then checked at the end of each block execution in the `on_finalize` hook.
             */
            DidUpdate: StorageDescriptor<[], boolean, false>;
        },
        {
            /**
             *See [`Pallet::set`].
             */
            set: TxDescriptor<Anonymize<Idcr6u6361oad9>>;
        },
        {},
        {},
        {
            /**
             * The minimum period between blocks.
             *
             * Be aware that this is different to the *expected* period that the block production
             * apparatus provides. Your chosen consensus system will generally work with this to
             * determine a sensible block time. For example, in the Aura pallet it will be double this
             * period on default settings.
             */
            MinimumPeriod: PlainDescriptor<bigint>;
        }
    ];
    Indices: [
        {
            /**
             * The lookup from index to account.
             */
            Accounts: StorageDescriptor<[Key: number], Anonymize<Iff9heri56m1mb>, true>;
        },
        {
            /**
             *See [`Pallet::claim`].
             */
            claim: TxDescriptor<Anonymize<I666bl2fqjkejo>>;
            /**
             *See [`Pallet::transfer`].
             */
            transfer: TxDescriptor<Anonymize<Idge7gk9m5car0>>;
            /**
             *See [`Pallet::free`].
             */
            free: TxDescriptor<Anonymize<I666bl2fqjkejo>>;
            /**
             *See [`Pallet::force_transfer`].
             */
            force_transfer: TxDescriptor<Anonymize<I34pbimt2i69v7>>;
            /**
             *See [`Pallet::freeze`].
             */
            freeze: TxDescriptor<Anonymize<I666bl2fqjkejo>>;
        },
        {
            /**
             *A account index was assigned.
             */
            IndexAssigned: PlainDescriptor<Anonymize<Ia1u3jll6a06ae>>;
            /**
             *A account index has been freed up (unassigned).
             */
            IndexFreed: PlainDescriptor<Anonymize<I666bl2fqjkejo>>;
            /**
             *A account index has been frozen to its current account ID.
             */
            IndexFrozen: PlainDescriptor<Anonymize<Ia1u3jll6a06ae>>;
        },
        {
            /**
             *The index was not already assigned.
             */
            NotAssigned: PlainDescriptor<undefined>;
            /**
             *The index is assigned to another account.
             */
            NotOwner: PlainDescriptor<undefined>;
            /**
             *The index was not available.
             */
            InUse: PlainDescriptor<undefined>;
            /**
             *The source and destination accounts are identical.
             */
            NotTransfer: PlainDescriptor<undefined>;
            /**
             *The index is permanent and may not be freed/changed.
             */
            Permanent: PlainDescriptor<undefined>;
        },
        {
            /**
             * The deposit needed for reserving an index.
             */
            Deposit: PlainDescriptor<bigint>;
        }
    ];
    Balances: [
        {
            /**
             * The total units issued in the system.
             */
            TotalIssuance: StorageDescriptor<[], bigint, false>;
            /**
             * The total units of outstanding deactivated balance in the system.
             */
            InactiveIssuance: StorageDescriptor<[], bigint, false>;
            /**
             * The Balances pallet example of storing the balance of an account.
             *
             * # Example
             *
             * ```nocompile
             *  impl pallet_balances::Config for Runtime {
             *    type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>
             *  }
             * ```
             *
             * You can also store the balance of an account in the `System` pallet.
             *
             * # Example
             *
             * ```nocompile
             *  impl pallet_balances::Config for Runtime {
             *   type AccountStore = System
             *  }
             * ```
             *
             * But this comes with tradeoffs, storing account balances in the system pallet stores
             * `frame_system` data alongside the account data contrary to storing account balances in the
             * `Balances` pallet, which uses a `StorageMap` to store balances data only.
             * NOTE: This is only used in the case that this pallet is used to store balances.
             */
            Account: StorageDescriptor<[Key: SS58String], Anonymize<I1q8tnt1cluu5j>, false>;
            /**
             * Any liquidity locks on some account balances.
             * NOTE: Should only be accessed when setting, changing and freeing a lock.
             */
            Locks: StorageDescriptor<[Key: SS58String], Anonymize<Ibtifm27unhnjf>, false>;
            /**
             * Named reserves on some account balances.
             */
            Reserves: StorageDescriptor<[Key: SS58String], Anonymize<Iactubn52acokl>, false>;
            /**
             * Holds on account balances.
             */
            Holds: StorageDescriptor<[Key: SS58String], Anonymize<I233put12fltor>, false>;
            /**
             * Freeze locks on account balances.
             */
            Freezes: StorageDescriptor<[Key: SS58String], Anonymize<Icqu54ik1fbovu>, false>;
        },
        {
            /**
             *See [`Pallet::transfer_allow_death`].
             */
            transfer_allow_death: TxDescriptor<Anonymize<Ien6q0lasi0m7i>>;
            /**
             *See [`Pallet::force_transfer`].
             */
            force_transfer: TxDescriptor<Anonymize<Icacgruoo9j3r2>>;
            /**
             *See [`Pallet::transfer_keep_alive`].
             */
            transfer_keep_alive: TxDescriptor<Anonymize<Ien6q0lasi0m7i>>;
            /**
             *See [`Pallet::transfer_all`].
             */
            transfer_all: TxDescriptor<Anonymize<I7dgmo7im9hljo>>;
            /**
             *See [`Pallet::force_unreserve`].
             */
            force_unreserve: TxDescriptor<Anonymize<Iargojp1sv9icj>>;
            /**
             *See [`Pallet::upgrade_accounts`].
             */
            upgrade_accounts: TxDescriptor<Anonymize<Ibmr18suc9ikh9>>;
            /**
             *See [`Pallet::force_set_balance`].
             */
            force_set_balance: TxDescriptor<Anonymize<Ie0io91hk7pejj>>;
        },
        {
            /**
             *An account was created with some free balance.
             */
            Endowed: PlainDescriptor<Anonymize<Icv68aq8841478>>;
            /**
             *An account was removed whose balance was non-zero but below ExistentialDeposit,
             *resulting in an outright loss.
             */
            DustLost: PlainDescriptor<Anonymize<Ic262ibdoec56a>>;
            /**
             *Transfer succeeded.
             */
            Transfer: PlainDescriptor<Anonymize<Iflcfm9b6nlmdd>>;
            /**
             *A balance was set by root.
             */
            BalanceSet: PlainDescriptor<Anonymize<Ijrsf4mnp3eka>>;
            /**
             *Some balance was reserved (moved from free to reserved).
             */
            Reserved: PlainDescriptor<Anonymize<Id5fm4p8lj5qgi>>;
            /**
             *Some balance was unreserved (moved from reserved to free).
             */
            Unreserved: PlainDescriptor<Anonymize<Id5fm4p8lj5qgi>>;
            /**
             *Some balance was moved from the reserve of the first account to the second account.
             *Final argument indicates the destination balance type.
             */
            ReserveRepatriated: PlainDescriptor<Anonymize<Idm5rqp3duosod>>;
            /**
             *Some amount was deposited (e.g. for transaction fees).
             */
            Deposit: PlainDescriptor<Anonymize<Id5fm4p8lj5qgi>>;
            /**
             *Some amount was withdrawn from the account (e.g. for transaction fees).
             */
            Withdraw: PlainDescriptor<Anonymize<Id5fm4p8lj5qgi>>;
            /**
             *Some amount was removed from the account (e.g. for misbehavior).
             */
            Slashed: PlainDescriptor<Anonymize<Id5fm4p8lj5qgi>>;
            /**
             *Some amount was minted into an account.
             */
            Minted: PlainDescriptor<Anonymize<Id5fm4p8lj5qgi>>;
            /**
             *Some amount was burned from an account.
             */
            Burned: PlainDescriptor<Anonymize<Id5fm4p8lj5qgi>>;
            /**
             *Some amount was suspended from an account (it can be restored later).
             */
            Suspended: PlainDescriptor<Anonymize<Id5fm4p8lj5qgi>>;
            /**
             *Some amount was restored into an account.
             */
            Restored: PlainDescriptor<Anonymize<Id5fm4p8lj5qgi>>;
            /**
             *An account was upgraded.
             */
            Upgraded: PlainDescriptor<Anonymize<I4cbvqmqadhrea>>;
            /**
             *Total issuance was increased by `amount`, creating a credit to be balanced.
             */
            Issued: PlainDescriptor<Anonymize<I3qt1hgg4djhgb>>;
            /**
             *Total issuance was decreased by `amount`, creating a debt to be balanced.
             */
            Rescinded: PlainDescriptor<Anonymize<I3qt1hgg4djhgb>>;
            /**
             *Some balance was locked.
             */
            Locked: PlainDescriptor<Anonymize<Id5fm4p8lj5qgi>>;
            /**
             *Some balance was unlocked.
             */
            Unlocked: PlainDescriptor<Anonymize<Id5fm4p8lj5qgi>>;
            /**
             *Some balance was frozen.
             */
            Frozen: PlainDescriptor<Anonymize<Id5fm4p8lj5qgi>>;
            /**
             *Some balance was thawed.
             */
            Thawed: PlainDescriptor<Anonymize<Id5fm4p8lj5qgi>>;
        },
        {
            /**
             *Vesting balance too high to send value.
             */
            VestingBalance: PlainDescriptor<undefined>;
            /**
             *Account liquidity restrictions prevent withdrawal.
             */
            LiquidityRestrictions: PlainDescriptor<undefined>;
            /**
             *Balance too low to send value.
             */
            InsufficientBalance: PlainDescriptor<undefined>;
            /**
             *Value too low to create account due to existential deposit.
             */
            ExistentialDeposit: PlainDescriptor<undefined>;
            /**
             *Transfer/payment would kill account.
             */
            Expendability: PlainDescriptor<undefined>;
            /**
             *A vesting schedule already exists for this account.
             */
            ExistingVestingSchedule: PlainDescriptor<undefined>;
            /**
             *Beneficiary account must pre-exist.
             */
            DeadAccount: PlainDescriptor<undefined>;
            /**
             *Number of named reserves exceed `MaxReserves`.
             */
            TooManyReserves: PlainDescriptor<undefined>;
            /**
             *Number of holds exceed `MaxHolds`.
             */
            TooManyHolds: PlainDescriptor<undefined>;
            /**
             *Number of freezes exceed `MaxFreezes`.
             */
            TooManyFreezes: PlainDescriptor<undefined>;
        },
        {
            /**
             * The minimum amount required to keep an account open. MUST BE GREATER THAN ZERO!
             *
             * If you *really* need it to be zero, you can enable the feature `insecure_zero_ed` for
             * this pallet. However, you do so at your own risk: this will open up a major DoS vector.
             * In case you have multiple sources of provider references, you may also get unexpected
             * behaviour if you set this to zero.
             *
             * Bottom line: Do yourself a favour and make it at least one!
             */
            ExistentialDeposit: PlainDescriptor<bigint>;
            /**
             * The maximum number of locks that should exist on an account.
             * Not strictly enforced, but used for weight estimation.
             */
            MaxLocks: PlainDescriptor<number>;
            /**
             * The maximum number of named reserves that can exist on an account.
             */
            MaxReserves: PlainDescriptor<number>;
            /**
             * The maximum number of holds that can exist on an account at any time.
             */
            MaxHolds: PlainDescriptor<number>;
            /**
             * The maximum number of individual freeze locks that can exist on an account at any time.
             */
            MaxFreezes: PlainDescriptor<number>;
        }
    ];
    TransactionPayment: [
        {
            /**
            
             */
            NextFeeMultiplier: StorageDescriptor<[], bigint, false>;
            /**
            
             */
            StorageVersion: StorageDescriptor<[], TransactionPaymentReleases, false>;
        },
        {},
        {
            /**
             *A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,
             *has been paid by `who`.
             */
            TransactionFeePaid: PlainDescriptor<Anonymize<Ier2cke86dqbr2>>;
        },
        {},
        {
            /**
             * A fee mulitplier for `Operational` extrinsics to compute "virtual tip" to boost their
             * `priority`
             *
             * This value is multipled by the `final_fee` to obtain a "virtual tip" that is later
             * added to a tip component in regular `priority` calculations.
             * It means that a `Normal` transaction can front-run a similarly-sized `Operational`
             * extrinsic (with no tip), by including a tip value greater than the virtual tip.
             *
             * ```rust,ignore
             * // For `Normal`
             * let priority = priority_calc(tip);
             *
             * // For `Operational`
             * let virtual_tip = (inclusion_fee + tip) * OperationalFeeMultiplier;
             * let priority = priority_calc(tip + virtual_tip);
             * ```
             *
             * Note that since we use `final_fee` the multiplier applies also to the regular `tip`
             * sent with the transaction. So, not only does the transaction get a priority bump based
             * on the `inclusion_fee`, but we also amplify the impact of tips applied to `Operational`
             * transactions.
             */
            OperationalFeeMultiplier: PlainDescriptor<number>;
        }
    ];
    Authorship: [
        {
            /**
             * Author of current block.
             */
            Author: StorageDescriptor<[], SS58String, true>;
        },
        {},
        {},
        {},
        {}
    ];
    Staking: [
        {
            /**
             * The ideal number of active validators.
             */
            ValidatorCount: StorageDescriptor<[], number, false>;
            /**
             * Minimum number of staking participants before emergency conditions are imposed.
             */
            MinimumValidatorCount: StorageDescriptor<[], number, false>;
            /**
             * Any validators that may never be slashed or forcibly kicked. It's a Vec since they're
             * easy to initialize and the performance hit is minimal (we expect no more than four
             * invulnerables) and restricted to testnets.
             */
            Invulnerables: StorageDescriptor<[], Anonymize<Ia2lhg7l2hilo3>, false>;
            /**
             * Map from all locked "stash" accounts to the controller account.
             *
             * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
             */
            Bonded: StorageDescriptor<[Key: SS58String], SS58String, true>;
            /**
             * The minimum active bond to become and maintain the role of a nominator.
             */
            MinNominatorBond: StorageDescriptor<[], bigint, false>;
            /**
             * The minimum active bond to become and maintain the role of a validator.
             */
            MinValidatorBond: StorageDescriptor<[], bigint, false>;
            /**
             * The minimum active nominator stake of the last successful election.
             */
            MinimumActiveStake: StorageDescriptor<[], bigint, false>;
            /**
             * The minimum amount of commission that validators can set.
             *
             * If set to `0`, no limit exists.
             */
            MinCommission: StorageDescriptor<[], number, false>;
            /**
             * Map from all (unlocked) "controller" accounts to the info regarding the staking.
             *
             * Note: All the reads and mutations to this storage *MUST* be done through the methods exposed
             * by [`StakingLedger`] to ensure data and lock consistency.
             */
            Ledger: StorageDescriptor<[Key: SS58String], Anonymize<I21nedsp35hoih>, true>;
            /**
             * Where the reward payment should be made. Keyed by stash.
             *
             * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
             */
            Payee: StorageDescriptor<[Key: SS58String], StakingRewardDestination, false>;
            /**
             * The map from (wannabe) validator stash key to the preferences of that validator.
             *
             * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
             */
            Validators: StorageDescriptor<[Key: SS58String], Anonymize<I9o7ssi9vmhmgr>, false>;
            /**
             *Counter for the related counted storage map
             */
            CounterForValidators: StorageDescriptor<[], number, false>;
            /**
             * The maximum validator count before we stop allowing new validators to join.
             *
             * When this value is not set, no limits are enforced.
             */
            MaxValidatorsCount: StorageDescriptor<[], number, true>;
            /**
             * The map from nominator stash key to their nomination preferences, namely the validators that
             * they wish to support.
             *
             * Note that the keys of this storage map might become non-decodable in case the
             * account's [`NominationsQuota::MaxNominations`] configuration is decreased.
             * In this rare case, these nominators
             * are still existent in storage, their key is correct and retrievable (i.e. `contains_key`
             * indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable
             * nominators will effectively not-exist, until they re-submit their preferences such that it
             * is within the bounds of the newly set `Config::MaxNominations`.
             *
             * This implies that `::iter_keys().count()` and `::iter().count()` might return different
             * values for this map. Moreover, the main `::count()` is aligned with the former, namely the
             * number of keys that exist.
             *
             * Lastly, if any of the nominators become non-decodable, they can be chilled immediately via
             * [`Call::chill_other`] dispatchable by anyone.
             *
             * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
             */
            Nominators: StorageDescriptor<[Key: SS58String], Anonymize<Ic3m9d6tdl6gi2>, true>;
            /**
             *Counter for the related counted storage map
             */
            CounterForNominators: StorageDescriptor<[], number, false>;
            /**
             * The maximum nominator count before we stop allowing new validators to join.
             *
             * When this value is not set, no limits are enforced.
             */
            MaxNominatorsCount: StorageDescriptor<[], number, true>;
            /**
             * The current era index.
             *
             * This is the latest planned era, depending on how the Session pallet queues the validator
             * set, it might be active or not.
             */
            CurrentEra: StorageDescriptor<[], number, true>;
            /**
             * The active era information, it holds index and start.
             *
             * The active era is the era being currently rewarded. Validator set of this era must be
             * equal to [`SessionInterface::validators`].
             */
            ActiveEra: StorageDescriptor<[], Anonymize<Ib3j7gb0jgs38u>, true>;
            /**
             * The session index at which the era start for the last `HISTORY_DEPTH` eras.
             *
             * Note: This tracks the starting session (i.e. session index when era start being active)
             * for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`.
             */
            ErasStartSessionIndex: StorageDescriptor<[Key: number], number, true>;
            /**
             * Exposure of validator at era.
             *
             * This is keyed first by the era index to allow bulk deletion and then the stash account.
             *
             * Is it removed after `HISTORY_DEPTH` eras.
             * If stakers hasn't been set or has been removed then empty exposure is returned.
             */
            ErasStakers: StorageDescriptor<Anonymize<I7svnfko10tq2e>, Anonymize<Ifekshcrgkl12g>, false>;
            /**
             * Clipped Exposure of validator at era.
             *
             * This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the
             * `T::MaxNominatorRewardedPerValidator` biggest stakers.
             * (Note: the field `total` and `own` of the exposure remains unchanged).
             * This is used to limit the i/o cost for the nominator payout.
             *
             * This is keyed fist by the era index to allow bulk deletion and then the stash account.
             *
             * Is it removed after `HISTORY_DEPTH` eras.
             * If stakers hasn't been set or has been removed then empty exposure is returned.
             */
            ErasStakersClipped: StorageDescriptor<Anonymize<I7svnfko10tq2e>, Anonymize<Ifekshcrgkl12g>, false>;
            /**
             * Similar to `ErasStakers`, this holds the preferences of validators.
             *
             * This is keyed first by the era index to allow bulk deletion and then the stash account.
             *
             * Is it removed after `HISTORY_DEPTH` eras.
             */
            ErasValidatorPrefs: StorageDescriptor<Anonymize<I7svnfko10tq2e>, Anonymize<I9o7ssi9vmhmgr>, false>;
            /**
             * The total validator era payout for the last `HISTORY_DEPTH` eras.
             *
             * Eras that haven't finished yet or has been removed doesn't have reward.
             */
            ErasValidatorReward: StorageDescriptor<[Key: number], bigint, true>;
            /**
             * Rewards for the last `HISTORY_DEPTH` eras.
             * If reward hasn't been set or has been removed then 0 reward is returned.
             */
            ErasRewardPoints: StorageDescriptor<[Key: number], Anonymize<Iff9p3c7k6pfoi>, false>;
            /**
             * The total amount staked for the last `HISTORY_DEPTH` eras.
             * If total hasn't been set or has been removed then 0 stake is returned.
             */
            ErasTotalStake: StorageDescriptor<[Key: number], bigint, false>;
            /**
             * Mode of era forcing.
             */
            ForceEra: StorageDescriptor<[], StakingForcing, false>;
            /**
             * The percentage of the slash that is distributed to reporters.
             *
             * The rest of the slashed value is handled by the `Slash`.
             */
            SlashRewardFraction: StorageDescriptor<[], number, false>;
            /**
             * The amount of currency given to reporters of a slash event which was
             * canceled by extraordinary circumstances (e.g. governance).
             */
            CanceledSlashPayout: StorageDescriptor<[], bigint, false>;
            /**
             * All unapplied slashes that are queued for later.
             */
            UnappliedSlashes: StorageDescriptor<[Key: number], Anonymize<Iafq6t4rgheait>, false>;
            /**
             * A mapping from still-bonded eras to the first session index of that era.
             *
             * Must contains information for eras for the range:
             * `[active_era - bounding_duration; active_era]`
             */
            BondedEras: StorageDescriptor<[], Anonymize<Iep4uo61810hfs>, false>;
            /**
             * All slashing events on validators, mapped by era to the highest slash proportion
             * and slash value of the era.
             */
            ValidatorSlashInEra: StorageDescriptor<Anonymize<I7svnfko10tq2e>, Anonymize<I4ojmnsk1dchql>, true>;
            /**
             * All slashing events on nominators, mapped by era to the highest slash value of the era.
             */
            NominatorSlashInEra: StorageDescriptor<Anonymize<I7svnfko10tq2e>, bigint, true>;
            /**
             * Slashing spans for stash accounts.
             */
            SlashingSpans: StorageDescriptor<[Key: SS58String], Anonymize<Iinkhfdlka9ch>, true>;
            /**
             * Records information about the maximum slash of a stash within a slashing span,
             * as well as how much reward has been paid out.
             */
            SpanSlash: StorageDescriptor<[Key: Anonymize<I6ouflveob4eli>], Anonymize<I2kj4j6mp68hf8>, false>;
            /**
             * The last planned session scheduled by the session pallet.
             *
             * This is basically in sync with the call to [`pallet_session::SessionManager::new_session`].
             */
            CurrentPlannedSession: StorageDescriptor<[], number, false>;
            /**
             * Indices of validators that have offended in the active era and whether they are currently
             * disabled.
             *
             * This value should be a superset of disabled validators since not all offences lead to the
             * validator being disabled (if there was no slash). This is needed to track the percentage of
             * validators that have offended in the current era, ensuring a new era is forced if
             * `OffendingValidatorsThreshold` is reached. The vec is always kept sorted so that we can find
             * whether a given validator has previously offended using binary search. It gets cleared when
             * the era ends.
             */
            OffendingValidators: StorageDescriptor<[], Anonymize<Ia9ek8s49lerat>, false>;
            /**
             * The threshold for when users can start calling `chill_other` for other validators /
             * nominators. The threshold is compared to the actual number of validators / nominators
             * (`CountFor*`) in the system compared to the configured max (`Max*Count`).
             */
            ChillThreshold: StorageDescriptor<[], number, true>;
        },
        {
            /**
             *See [`Pallet::bond`].
             */
            bond: TxDescriptor<Anonymize<I9f7ms9viml8of>>;
            /**
             *See [`Pallet::bond_extra`].
             */
            bond_extra: TxDescriptor<Anonymize<I564va64vtidbq>>;
            /**
             *See [`Pallet::unbond`].
             */
            unbond: TxDescriptor<Anonymize<Ie5v6njpckr05b>>;
            /**
             *See [`Pallet::withdraw_unbonded`].
             */
            withdraw_unbonded: TxDescriptor<Anonymize<I328av3j0bgmjb>>;
            /**
             *See [`Pallet::validate`].
             */
            validate: TxDescriptor<Anonymize<I4tuqm9ato907i>>;
            /**
             *See [`Pallet::nominate`].
             */
            nominate: TxDescriptor<Anonymize<I5n9nf1mhg26dt>>;
            /**
             *See [`Pallet::chill`].
             */
            chill: TxDescriptor<undefined>;
            /**
             *See [`Pallet::set_payee`].
             */
            set_payee: TxDescriptor<Anonymize<Ida5hg7geddnc7>>;
            /**
             *See [`Pallet::set_controller`].
             */
            set_controller: TxDescriptor<undefined>;
            /**
             *See [`Pallet::set_validator_count`].
             */
            set_validator_count: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::increase_validator_count`].
             */
            increase_validator_count: TxDescriptor<Anonymize<Ifhs60omlhvt3>>;
            /**
             *See [`Pallet::scale_validator_count`].
             */
            scale_validator_count: TxDescriptor<Anonymize<If34udpd5e57vi>>;
            /**
             *See [`Pallet::force_no_eras`].
             */
            force_no_eras: TxDescriptor<undefined>;
            /**
             *See [`Pallet::force_new_era`].
             */
            force_new_era: TxDescriptor<undefined>;
            /**
             *See [`Pallet::set_invulnerables`].
             */
            set_invulnerables: TxDescriptor<Anonymize<I39t01nnod9109>>;
            /**
             *See [`Pallet::force_unstake`].
             */
            force_unstake: TxDescriptor<Anonymize<Ie5vbnd9198quk>>;
            /**
             *See [`Pallet::force_new_era_always`].
             */
            force_new_era_always: TxDescriptor<undefined>;
            /**
             *See [`Pallet::cancel_deferred_slash`].
             */
            cancel_deferred_slash: TxDescriptor<Anonymize<I3h6murn8bd4v5>>;
            /**
             *See [`Pallet::payout_stakers`].
             */
            payout_stakers: TxDescriptor<Anonymize<I6k6jf8ncesuu3>>;
            /**
             *See [`Pallet::rebond`].
             */
            rebond: TxDescriptor<Anonymize<Ie5v6njpckr05b>>;
            /**
             *See [`Pallet::reap_stash`].
             */
            reap_stash: TxDescriptor<Anonymize<Ie5vbnd9198quk>>;
            /**
             *See [`Pallet::kick`].
             */
            kick: TxDescriptor<Anonymize<I2j5nkj9u94qun>>;
            /**
             *See [`Pallet::set_staking_configs`].
             */
            set_staking_configs: TxDescriptor<Anonymize<I9nfsuc9smbmvv>>;
            /**
             *See [`Pallet::chill_other`].
             */
            chill_other: TxDescriptor<Anonymize<I3v6ks33uluhnj>>;
            /**
             *See [`Pallet::force_apply_min_commission`].
             */
            force_apply_min_commission: TxDescriptor<Anonymize<I5ont0141q9ss5>>;
            /**
             *See [`Pallet::set_min_commission`].
             */
            set_min_commission: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
        },
        {
            /**
             *The era payout has been set; the first balance is the validator-payout; the second is
             *the remainder from the maximum amount of reward.
             */
            EraPaid: PlainDescriptor<Anonymize<I1au3fq4n84nv3>>;
            /**
             *The nominator has been rewarded by this amount to this destination.
             */
            Rewarded: PlainDescriptor<Anonymize<I5j22i27djc5r4>>;
            /**
             *A staker (validator or nominator) has been slashed by the given amount.
             */
            Slashed: PlainDescriptor<Anonymize<Idnak900lt5lm8>>;
            /**
             *A slash for the given validator, for the given percentage of their stake, at the given
             *era as been reported.
             */
            SlashReported: PlainDescriptor<Anonymize<I27n7lbd66730p>>;
            /**
             *An old slashing report from a prior era was discarded because it could
             *not be processed.
             */
            OldSlashingReportDiscarded: PlainDescriptor<Anonymize<I2hq50pu2kdjpo>>;
            /**
             *A new set of stakers was elected.
             */
            StakersElected: PlainDescriptor<undefined>;
            /**
             *An account has bonded this amount. \[stash, amount\]
             *
             *NOTE: This event is only emitted when funds are bonded via a dispatchable. Notably,
             *it will not be emitted for staking rewards when they are added to stake.
             */
            Bonded: PlainDescriptor<Anonymize<Ifk8eme5o7mukf>>;
            /**
             *An account has unbonded this amount.
             */
            Unbonded: PlainDescriptor<Anonymize<Ifk8eme5o7mukf>>;
            /**
             *An account has called `withdraw_unbonded` and removed unbonding chunks worth `Balance`
             *from the unlocking queue.
             */
            Withdrawn: PlainDescriptor<Anonymize<Ifk8eme5o7mukf>>;
            /**
             *A nominator has been kicked from a validator.
             */
            Kicked: PlainDescriptor<Anonymize<Iau4cgm6ih61cf>>;
            /**
             *The election failed. No new era is planned.
             */
            StakingElectionFailed: PlainDescriptor<undefined>;
            /**
             *An account has stopped participating as either a validator or nominator.
             */
            Chilled: PlainDescriptor<Anonymize<Idl3umm12u5pa>>;
            /**
             *The stakers' rewards are getting paid.
             */
            PayoutStarted: PlainDescriptor<Anonymize<I6ir616rur362k>>;
            /**
             *A validator has set their preferences.
             */
            ValidatorPrefsSet: PlainDescriptor<Anonymize<Ic19as7nbst738>>;
            /**
             *Voters size limit reached.
             */
            SnapshotVotersSizeExceeded: PlainDescriptor<Anonymize<I54umskavgc9du>>;
            /**
             *Targets size limit reached.
             */
            SnapshotTargetsSizeExceeded: PlainDescriptor<Anonymize<I54umskavgc9du>>;
            /**
             *A new force era mode was set.
             */
            ForceEra: PlainDescriptor<Anonymize<I43l31t29k2o0p>>;
        },
        {
            /**
             *Not a controller account.
             */
            NotController: PlainDescriptor<undefined>;
            /**
             *Not a stash account.
             */
            NotStash: PlainDescriptor<undefined>;
            /**
             *Stash is already bonded.
             */
            AlreadyBonded: PlainDescriptor<undefined>;
            /**
             *Controller is already paired.
             */
            AlreadyPaired: PlainDescriptor<undefined>;
            /**
             *Targets cannot be empty.
             */
            EmptyTargets: PlainDescriptor<undefined>;
            /**
             *Duplicate index.
             */
            DuplicateIndex: PlainDescriptor<undefined>;
            /**
             *Slash record index out of bounds.
             */
            InvalidSlashIndex: PlainDescriptor<undefined>;
            /**
             *Cannot have a validator or nominator role, with value less than the minimum defined by
             *governance (see `MinValidatorBond` and `MinNominatorBond`). If unbonding is the
             *intention, `chill` first to remove one's role as validator/nominator.
             */
            InsufficientBond: PlainDescriptor<undefined>;
            /**
             *Can not schedule more unlock chunks.
             */
            NoMoreChunks: PlainDescriptor<undefined>;
            /**
             *Can not rebond without unlocking chunks.
             */
            NoUnlockChunk: PlainDescriptor<undefined>;
            /**
             *Attempting to target a stash that still has funds.
             */
            FundedTarget: PlainDescriptor<undefined>;
            /**
             *Invalid era to reward.
             */
            InvalidEraToReward: PlainDescriptor<undefined>;
            /**
             *Invalid number of nominations.
             */
            InvalidNumberOfNominations: PlainDescriptor<undefined>;
            /**
             *Items are not sorted and unique.
             */
            NotSortedAndUnique: PlainDescriptor<undefined>;
            /**
             *Rewards for this era have already been claimed for this validator.
             */
            AlreadyClaimed: PlainDescriptor<undefined>;
            /**
             *Incorrect previous history depth input provided.
             */
            IncorrectHistoryDepth: PlainDescriptor<undefined>;
            /**
             *Incorrect number of slashing spans provided.
             */
            IncorrectSlashingSpans: PlainDescriptor<undefined>;
            /**
             *Internal state has become somehow corrupted and the operation cannot continue.
             */
            BadState: PlainDescriptor<undefined>;
            /**
             *Too many nomination targets supplied.
             */
            TooManyTargets: PlainDescriptor<undefined>;
            /**
             *A nomination target was supplied that was blocked or otherwise not a validator.
             */
            BadTarget: PlainDescriptor<undefined>;
            /**
             *The user has enough bond and thus cannot be chilled forcefully by an external person.
             */
            CannotChillOther: PlainDescriptor<undefined>;
            /**
             *There are too many nominators in the system. Governance needs to adjust the staking
             *settings to keep things safe for the runtime.
             */
            TooManyNominators: PlainDescriptor<undefined>;
            /**
             *There are too many validator candidates in the system. Governance needs to adjust the
             *staking settings to keep things safe for the runtime.
             */
            TooManyValidators: PlainDescriptor<undefined>;
            /**
             *Commission is too low. Must be at least `MinCommission`.
             */
            CommissionTooLow: PlainDescriptor<undefined>;
            /**
             *Some bound is not met.
             */
            BoundNotMet: PlainDescriptor<undefined>;
        },
        {
            /**
             * Number of eras to keep in history.
             *
             * Following information is kept for eras in `[current_era -
             * HistoryDepth, current_era]`: `ErasStakers`, `ErasStakersClipped`,
             * `ErasValidatorPrefs`, `ErasValidatorReward`, `ErasRewardPoints`,
             * `ErasTotalStake`, `ErasStartSessionIndex`,
             * `StakingLedger.claimed_rewards`.
             *
             * Must be more than the number of eras delayed by session.
             * I.e. active era must always be in history. I.e. `active_era >
             * current_era - history_depth` must be guaranteed.
             *
             * If migrating an existing pallet from storage value to config value,
             * this should be set to same value or greater as in storage.
             *
             * Note: `HistoryDepth` is used as the upper bound for the `BoundedVec`
             * item `StakingLedger.claimed_rewards`. Setting this value lower than
             * the existing value can lead to inconsistencies in the
             * `StakingLedger` and will need to be handled properly in a migration.
             * The test `reducing_history_depth_abrupt` shows this effect.
             */
            HistoryDepth: PlainDescriptor<number>;
            /**
             * Number of sessions per era.
             */
            SessionsPerEra: PlainDescriptor<number>;
            /**
             * Number of eras that staked funds must remain bonded for.
             */
            BondingDuration: PlainDescriptor<number>;
            /**
             * Number of eras that slashes are deferred by, after computation.
             *
             * This should be less than the bonding duration. Set to 0 if slashes
             * should be applied immediately, without opportunity for intervention.
             */
            SlashDeferDuration: PlainDescriptor<number>;
            /**
             * The maximum number of nominators rewarded for each validator.
             *
             * For each validator only the `$MaxNominatorRewardedPerValidator` biggest stakers can
             * claim their reward. This used to limit the i/o cost for the nominator payout.
             */
            MaxNominatorRewardedPerValidator: PlainDescriptor<number>;
            /**
             * The maximum number of `unlocking` chunks a [`StakingLedger`] can
             * have. Effectively determines how many unique eras a staker may be
             * unbonding in.
             *
             * Note: `MaxUnlockingChunks` is used as the upper bound for the
             * `BoundedVec` item `StakingLedger.unlocking`. Setting this value
             * lower than the existing value can lead to inconsistencies in the
             * `StakingLedger` and will need to be handled properly in a runtime
             * migration. The test `reducing_max_unlocking_chunks_abrupt` shows
             * this effect.
             */
            MaxUnlockingChunks: PlainDescriptor<number>;
        }
    ];
    Offences: [
        {
            /**
             * The primary structure that holds all offence records keyed by report identifiers.
             */
            Reports: StorageDescriptor<[Key: Binary], Anonymize<I2bqvqrg0sbrdj>, true>;
            /**
             * A vector of reports of the same kind that happened at the same time slot.
             */
            ConcurrentReportsIndex: StorageDescriptor<Anonymize<Iasase33a12046>, Anonymize<Idhnf6rtqoslea>, false>;
        },
        {},
        {
            /**
             *There is an offence reported of the given `kind` happened at the `session_index` and
             *(kind-specific) time slot. This event is not deposited for duplicate slashes.
             *\[kind, timeslot\].
             */
            Offence: PlainDescriptor<Anonymize<I41n4hddrgegvb>>;
        },
        {},
        {}
    ];
    Historical: [{}, {}, {}, {}, {}];
    Session: [
        {
            /**
             * The current set of validators.
             */
            Validators: StorageDescriptor<[], Anonymize<Ia2lhg7l2hilo3>, false>;
            /**
             * Current index of the session.
             */
            CurrentIndex: StorageDescriptor<[], number, false>;
            /**
             * True if the underlying economic identities or weighting behind the validators
             * has changed in the queued validator set.
             */
            QueuedChanged: StorageDescriptor<[], boolean, false>;
            /**
             * The queued keys for the next session. When the next session begins, these keys
             * will be used to determine the validator's session keys.
             */
            QueuedKeys: StorageDescriptor<[], Anonymize<I6gic9mme18mpd>, false>;
            /**
             * Indices of disabled validators.
             *
             * The vec is always kept sorted so that we can find whether a given validator is
             * disabled using binary search. It gets cleared when `on_session_ending` returns
             * a new set of identities.
             */
            DisabledValidators: StorageDescriptor<[], Anonymize<Icgljjb6j82uhn>, false>;
            /**
             * The next session keys for a validator.
             */
            NextKeys: StorageDescriptor<[Key: SS58String], Anonymize<I4g61cdhi06s1m>, true>;
            /**
             * The owner of a key. The key is the `KeyTypeId` + the encoded key.
             */
            KeyOwner: StorageDescriptor<[Key: Anonymize<Idhk5e7nto8mrb>], SS58String, true>;
        },
        {
            /**
             *See [`Pallet::set_keys`].
             */
            set_keys: TxDescriptor<Anonymize<Ifu2fv3jk8vbos>>;
            /**
             *See [`Pallet::purge_keys`].
             */
            purge_keys: TxDescriptor<undefined>;
        },
        {
            /**
             *New session has happened. Note that the argument is the session index, not the
             *block number as the type might suggest.
             */
            NewSession: PlainDescriptor<Anonymize<I2hq50pu2kdjpo>>;
        },
        {
            /**
             *Invalid ownership proof.
             */
            InvalidProof: PlainDescriptor<undefined>;
            /**
             *No associated validator ID for account.
             */
            NoAssociatedValidatorId: PlainDescriptor<undefined>;
            /**
             *Registered duplicate key.
             */
            DuplicatedKey: PlainDescriptor<undefined>;
            /**
             *No keys are associated with this account.
             */
            NoKeys: PlainDescriptor<undefined>;
            /**
             *Key setting account is not live, so it's impossible to associate keys.
             */
            NoAccount: PlainDescriptor<undefined>;
        },
        {}
    ];
    Grandpa: [
        {
            /**
             * State of the current authority set.
             */
            State: StorageDescriptor<[], GrandpaStoredState, false>;
            /**
             * Pending change: (signaled at, scheduled change).
             */
            PendingChange: StorageDescriptor<[], Anonymize<Ibu50q5vhsfq5e>, true>;
            /**
             * next block number where we can force a change.
             */
            NextForced: StorageDescriptor<[], number, true>;
            /**
             * `true` if we are currently stalled.
             */
            Stalled: StorageDescriptor<[], Anonymize<I5g2vv0ckl2m8b>, true>;
            /**
             * The number of changes (both in terms of keys and underlying economic responsibilities)
             * in the "set" of Grandpa validators from genesis.
             */
            CurrentSetId: StorageDescriptor<[], bigint, false>;
            /**
             * A mapping from grandpa set ID to the index of the *most recent* session for which its
             * members were responsible.
             *
             * This is only used for validating equivocation proofs. An equivocation proof must
             * contains a key-ownership proof for a given session, therefore we need a way to tie
             * together sessions and GRANDPA set ids, i.e. we need to validate that a validator
             * was the owner of a given key on a given session, and what the active set ID was
             * during that session.
             *
             * TWOX-NOTE: `SetId` is not under user control.
             */
            SetIdSession: StorageDescriptor<[Key: bigint], number, true>;
        },
        {
            /**
             *See [`Pallet::report_equivocation`].
             */
            report_equivocation: TxDescriptor<Anonymize<I4kjek1q6rj24q>>;
            /**
             *See [`Pallet::report_equivocation_unsigned`].
             */
            report_equivocation_unsigned: TxDescriptor<Anonymize<I4kjek1q6rj24q>>;
            /**
             *See [`Pallet::note_stalled`].
             */
            note_stalled: TxDescriptor<Anonymize<I2hviml3snvhhn>>;
        },
        {
            /**
             *New authority set has been applied.
             */
            NewAuthorities: PlainDescriptor<Anonymize<Ib31jedabim0q7>>;
            /**
             *Current authority set has been paused.
             */
            Paused: PlainDescriptor<undefined>;
            /**
             *Current authority set has been resumed.
             */
            Resumed: PlainDescriptor<undefined>;
        },
        {
            /**
             *Attempt to signal GRANDPA pause when the authority set isn't live
             *(either paused or already pending pause).
             */
            PauseFailed: PlainDescriptor<undefined>;
            /**
             *Attempt to signal GRANDPA resume when the authority set isn't paused
             *(either live or already pending resume).
             */
            ResumeFailed: PlainDescriptor<undefined>;
            /**
             *Attempt to signal GRANDPA change with one already pending.
             */
            ChangePending: PlainDescriptor<undefined>;
            /**
             *Cannot signal forced change so soon after last.
             */
            TooSoon: PlainDescriptor<undefined>;
            /**
             *A key ownership proof provided as part of an equivocation report is invalid.
             */
            InvalidKeyOwnershipProof: PlainDescriptor<undefined>;
            /**
             *An equivocation proof provided as part of an equivocation report is invalid.
             */
            InvalidEquivocationProof: PlainDescriptor<undefined>;
            /**
             *A given equivocation report is valid but already previously reported.
             */
            DuplicateOffenceReport: PlainDescriptor<undefined>;
        },
        {
            /**
             * Max Authorities in use
             */
            MaxAuthorities: PlainDescriptor<number>;
            /**
             * The maximum number of nominators for each validator.
             */
            MaxNominators: PlainDescriptor<number>;
            /**
             * The maximum number of entries to keep in the set id to session index mapping.
             *
             * Since the `SetIdSession` map is only used for validating equivocations this
             * value should relate to the bonding duration of whatever staking system is
             * being used (if any). If equivocation handling is not enabled then this value
             * can be zero.
             */
            MaxSetIdSessionEntries: PlainDescriptor<bigint>;
        }
    ];
    ImOnline: [
        {
            /**
             * The block number after which it's ok to send heartbeats in the current
             * session.
             *
             * At the beginning of each session we set this to a value that should fall
             * roughly in the middle of the session duration. The idea is to first wait for
             * the validators to produce a block in the current session, so that the
             * heartbeat later on will not be necessary.
             *
             * This value will only be used as a fallback if we fail to get a proper session
             * progress estimate from `NextSessionRotation`, as those estimates should be
             * more accurate then the value we calculate for `HeartbeatAfter`.
             */
            HeartbeatAfter: StorageDescriptor<[], number, false>;
            /**
             * The current set of keys that may issue a heartbeat.
             */
            Keys: StorageDescriptor<[], Anonymize<Idhnf6rtqoslea>, false>;
            /**
             * For each session index, we keep a mapping of `SessionIndex` and `AuthIndex`.
             */
            ReceivedHeartbeats: StorageDescriptor<Anonymize<I5g2vv0ckl2m8b>, boolean, true>;
            /**
             * For each session index, we keep a mapping of `ValidatorId<T>` to the
             * number of blocks authored by the given authority.
             */
            AuthoredBlocks: StorageDescriptor<Anonymize<I7svnfko10tq2e>, number, false>;
        },
        {
            /**
             *See [`Pallet::heartbeat`].
             */
            heartbeat: TxDescriptor<Anonymize<Ifgbq9oil78ogk>>;
        },
        {
            /**
             *A new heartbeat was received from `AuthorityId`.
             */
            HeartbeatReceived: PlainDescriptor<Anonymize<I93nne97c4i0sr>>;
            /**
             *At the end of the session, no offence was committed.
             */
            AllGood: PlainDescriptor<undefined>;
            /**
             *At the end of the session, at least one validator was found to be offline.
             */
            SomeOffline: PlainDescriptor<Anonymize<I311vp8270bfmr>>;
        },
        {
            /**
             *Non existent public key.
             */
            InvalidKey: PlainDescriptor<undefined>;
            /**
             *Duplicated heartbeat.
             */
            DuplicatedHeartbeat: PlainDescriptor<undefined>;
        },
        {
            /**
             * A configuration for base priority of unsigned transactions.
             *
             * This is exposed so that it can be tuned for particular runtime, when
             * multiple pallets send unsigned transactions.
             */
            UnsignedPriority: PlainDescriptor<bigint>;
        }
    ];
    AuthorityDiscovery: [{}, {}, {}, {}, {}];
    Treasury: [
        {
            /**
             * Number of proposals that have been made.
             */
            ProposalCount: StorageDescriptor<[], number, false>;
            /**
             * Proposals that have been made.
             */
            Proposals: StorageDescriptor<[Key: number], Anonymize<Iegmj7n48sc3am>, true>;
            /**
             * The amount which has been reported as inactive to Currency.
             */
            Deactivated: StorageDescriptor<[], bigint, false>;
            /**
             * Proposal indices that have been approved but not yet awarded.
             */
            Approvals: StorageDescriptor<[], Anonymize<Icgljjb6j82uhn>, false>;
            /**
             * The count of spends that have been made.
             */
            SpendCount: StorageDescriptor<[], number, false>;
            /**
             * Spends that have been approved and being processed.
             */
            Spends: StorageDescriptor<[Key: number], Anonymize<Ie05qfg5feue1l>, true>;
        },
        {
            /**
             *See [`Pallet::propose_spend`].
             */
            propose_spend: TxDescriptor<Anonymize<I5c883qnnqciv8>>;
            /**
             *See [`Pallet::reject_proposal`].
             */
            reject_proposal: TxDescriptor<Anonymize<Icm9m0qeemu66d>>;
            /**
             *See [`Pallet::approve_proposal`].
             */
            approve_proposal: TxDescriptor<Anonymize<Icm9m0qeemu66d>>;
            /**
             *See [`Pallet::spend_local`].
             */
            spend_local: TxDescriptor<Anonymize<Idpn74s0i9cdvp>>;
            /**
             *See [`Pallet::remove_approval`].
             */
            remove_approval: TxDescriptor<Anonymize<Icm9m0qeemu66d>>;
            /**
             *See [`Pallet::spend`].
             */
            spend: TxDescriptor<Anonymize<I815t7ta25e227>>;
            /**
             *See [`Pallet::payout`].
             */
            payout: TxDescriptor<Anonymize<I666bl2fqjkejo>>;
            /**
             *See [`Pallet::check_status`].
             */
            check_status: TxDescriptor<Anonymize<I666bl2fqjkejo>>;
            /**
             *See [`Pallet::void_spend`].
             */
            void_spend: TxDescriptor<Anonymize<I666bl2fqjkejo>>;
        },
        {
            /**
             *New proposal.
             */
            Proposed: PlainDescriptor<Anonymize<I44hc4lgsn4o1j>>;
            /**
             *We have ended a spend period and will now allocate funds.
             */
            Spending: PlainDescriptor<Anonymize<I8iksqi3eani0a>>;
            /**
             *Some funds have been allocated.
             */
            Awarded: PlainDescriptor<Anonymize<I16enopmju1p0q>>;
            /**
             *A proposal was rejected; funds were slashed.
             */
            Rejected: PlainDescriptor<Anonymize<Ifgqhle2413de7>>;
            /**
             *Some of our funds have been burnt.
             */
            Burnt: PlainDescriptor<Anonymize<I43kq8qudg7pq9>>;
            /**
             *Spending has finished; this is the amount that rolls over until next spend.
             */
            Rollover: PlainDescriptor<Anonymize<I76riseemre533>>;
            /**
             *Some funds have been deposited.
             */
            Deposit: PlainDescriptor<Anonymize<Ie5v6njpckr05b>>;
            /**
             *A new spend proposal has been approved.
             */
            SpendApproved: PlainDescriptor<Anonymize<I38bmcrmh852rk>>;
            /**
             *The inactive funds of the pallet have been updated.
             */
            UpdatedInactive: PlainDescriptor<Anonymize<I4hcillge8de5f>>;
            /**
             *A new asset spend proposal has been approved.
             */
            AssetSpendApproved: PlainDescriptor<Anonymize<Iblqf6usek6oij>>;
            /**
             *An approved spend was voided.
             */
            AssetSpendVoided: PlainDescriptor<Anonymize<I666bl2fqjkejo>>;
            /**
             *A payment happened.
             */
            Paid: PlainDescriptor<Anonymize<Iek7v4hrgnq6iv>>;
            /**
             *A payment failed and can be retried.
             */
            PaymentFailed: PlainDescriptor<Anonymize<Iek7v4hrgnq6iv>>;
            /**
             *A spend was processed and removed from the storage. It might have been successfully
             *paid or it may have expired.
             */
            SpendProcessed: PlainDescriptor<Anonymize<I666bl2fqjkejo>>;
        },
        {
            /**
             *Proposer's balance is too low.
             */
            InsufficientProposersBalance: PlainDescriptor<undefined>;
            /**
             *No proposal, bounty or spend at that index.
             */
            InvalidIndex: PlainDescriptor<undefined>;
            /**
             *Too many approvals in the queue.
             */
            TooManyApprovals: PlainDescriptor<undefined>;
            /**
             *The spend origin is valid but the amount it is allowed to spend is lower than the
             *amount to be spent.
             */
            InsufficientPermission: PlainDescriptor<undefined>;
            /**
             *Proposal has not been approved.
             */
            ProposalNotApproved: PlainDescriptor<undefined>;
            /**
             *The balance of the asset kind is not convertible to the balance of the native asset.
             */
            FailedToConvertBalance: PlainDescriptor<undefined>;
            /**
             *The spend has expired and cannot be claimed.
             */
            SpendExpired: PlainDescriptor<undefined>;
            /**
             *The spend is not yet eligible for payout.
             */
            EarlyPayout: PlainDescriptor<undefined>;
            /**
             *The payment has already been attempted.
             */
            AlreadyAttempted: PlainDescriptor<undefined>;
            /**
             *There was some issue with the mechanism of payment.
             */
            PayoutError: PlainDescriptor<undefined>;
            /**
             *The payout was not yet attempted/claimed.
             */
            NotAttempted: PlainDescriptor<undefined>;
            /**
             *The payment has neither failed nor succeeded yet.
             */
            Inconclusive: PlainDescriptor<undefined>;
        },
        {
            /**
             * Fraction of a proposal's value that should be bonded in order to place the proposal.
             * An accepted proposal gets these back. A rejected proposal does not.
             */
            ProposalBond: PlainDescriptor<number>;
            /**
             * Minimum amount of funds that should be placed in a deposit for making a proposal.
             */
            ProposalBondMinimum: PlainDescriptor<bigint>;
            /**
             * Maximum amount of funds that should be placed in a deposit for making a proposal.
             */
            ProposalBondMaximum: PlainDescriptor<Anonymize<I35p85j063s0il>>;
            /**
             * Period between successive spends.
             */
            SpendPeriod: PlainDescriptor<number>;
            /**
             * Percentage of spare funds (if any) that are burnt per spend period.
             */
            Burn: PlainDescriptor<number>;
            /**
             * The treasury's pallet id, used for deriving its sovereign account ID.
             */
            PalletId: PlainDescriptor<Binary>;
            /**
             * The maximum number of approvals that can wait in the spending queue.
             *
             * NOTE: This parameter is also used within the Bounties Pallet extension if enabled.
             */
            MaxApprovals: PlainDescriptor<number>;
            /**
             * The period during which an approved treasury spend has to be claimed.
             */
            PayoutPeriod: PlainDescriptor<number>;
        }
    ];
    ConvictionVoting: [
        {
            /**
             * All voting for a particular voter in a particular voting class. We store the balance for the
             * number of votes that we have recorded.
             */
            VotingFor: StorageDescriptor<Anonymize<I6ouflveob4eli>, ConvictionVotingVoteVoting, false>;
            /**
             * The voting classes which have a non-zero lock requirement and the lock amounts which they
             * require. The actual amount locked on behalf of this pallet should always be the maximum of
             * this list.
             */
            ClassLocksFor: StorageDescriptor<[Key: SS58String], Anonymize<If9jidduiuq7vv>, false>;
        },
        {
            /**
             *See [`Pallet::vote`].
             */
            vote: TxDescriptor<Anonymize<Idnsr2pndm36h0>>;
            /**
             *See [`Pallet::delegate`].
             */
            delegate: TxDescriptor<Anonymize<Id7ut33dljf52c>>;
            /**
             *See [`Pallet::undelegate`].
             */
            undelegate: TxDescriptor<Anonymize<I8steo882k7qns>>;
            /**
             *See [`Pallet::unlock`].
             */
            unlock: TxDescriptor<Anonymize<I1vc8h4t228bot>>;
            /**
             *See [`Pallet::remove_vote`].
             */
            remove_vote: TxDescriptor<Anonymize<I5f178ab6b89t3>>;
            /**
             *See [`Pallet::remove_other_vote`].
             */
            remove_other_vote: TxDescriptor<Anonymize<I5fak1u82ohqtm>>;
        },
        {
            /**
             *An account has delegated their vote to another account. \[who, target\]
             */
            Delegated: PlainDescriptor<Anonymize<Ic5oktqtdlvdvq>>;
            /**
             *An \[account\] has cancelled a previous delegation operation.
             */
            Undelegated: PlainDescriptor<SS58String>;
        },
        {
            /**
             *Poll is not ongoing.
             */
            NotOngoing: PlainDescriptor<undefined>;
            /**
             *The given account did not vote on the poll.
             */
            NotVoter: PlainDescriptor<undefined>;
            /**
             *The actor has no permission to conduct the action.
             */
            NoPermission: PlainDescriptor<undefined>;
            /**
             *The actor has no permission to conduct the action right now but will do in the future.
             */
            NoPermissionYet: PlainDescriptor<undefined>;
            /**
             *The account is already delegating.
             */
            AlreadyDelegating: PlainDescriptor<undefined>;
            /**
             *The account currently has votes attached to it and the operation cannot succeed until
             *these are removed, either through `unvote` or `reap_vote`.
             */
            AlreadyVoting: PlainDescriptor<undefined>;
            /**
             *Too high a balance was provided that the account cannot afford.
             */
            InsufficientFunds: PlainDescriptor<undefined>;
            /**
             *The account is not currently delegating.
             */
            NotDelegating: PlainDescriptor<undefined>;
            /**
             *Delegation to oneself makes no sense.
             */
            Nonsense: PlainDescriptor<undefined>;
            /**
             *Maximum number of votes reached.
             */
            MaxVotesReached: PlainDescriptor<undefined>;
            /**
             *The class must be supplied since it is not easily determinable from the state.
             */
            ClassNeeded: PlainDescriptor<undefined>;
            /**
             *The class ID supplied is invalid.
             */
            BadClass: PlainDescriptor<undefined>;
        },
        {
            /**
             * The maximum number of concurrent votes an account may have.
             *
             * Also used to compute weight, an overly large value can lead to extrinsics with large
             * weight estimation: see `delegate` for instance.
             */
            MaxVotes: PlainDescriptor<number>;
            /**
             * The minimum period of vote locking.
             *
             * It should be no shorter than enactment period to ensure that in the case of an approval,
             * those successful voters are locked into the consequences that their votes entail.
             */
            VoteLockingPeriod: PlainDescriptor<number>;
        }
    ];
    Referenda: [
        {
            /**
             * The next free referendum index, aka the number of referenda started so far.
             */
            ReferendumCount: StorageDescriptor<[], number, false>;
            /**
             * Information concerning any given referendum.
             */
            ReferendumInfoFor: StorageDescriptor<[Key: number], ReferendaTypesReferendumInfo, true>;
            /**
             * The sorted list of referenda ready to be decided but not yet being decided, ordered by
             * conviction-weighted approvals.
             *
             * This should be empty if `DecidingCount` is less than `TrackInfo::max_deciding`.
             */
            TrackQueue: StorageDescriptor<[Key: number], Anonymize<If9jidduiuq7vv>, false>;
            /**
             * The number of referenda being decided currently.
             */
            DecidingCount: StorageDescriptor<[Key: number], number, false>;
            /**
             * The metadata is a general information concerning the referendum.
             * The `Hash` refers to the preimage of the `Preimages` provider which can be a JSON
             * dump or IPFS hash of a JSON file.
             *
             * Consider a garbage collection for a metadata of finished referendums to `unrequest` (remove)
             * large preimages.
             */
            MetadataOf: StorageDescriptor<[Key: number], Binary, true>;
        },
        {
            /**
             *See [`Pallet::submit`].
             */
            submit: TxDescriptor<Anonymize<I86t0cca08a1h1>>;
            /**
             *See [`Pallet::place_decision_deposit`].
             */
            place_decision_deposit: TxDescriptor<Anonymize<I666bl2fqjkejo>>;
            /**
             *See [`Pallet::refund_decision_deposit`].
             */
            refund_decision_deposit: TxDescriptor<Anonymize<I666bl2fqjkejo>>;
            /**
             *See [`Pallet::cancel`].
             */
            cancel: TxDescriptor<Anonymize<I666bl2fqjkejo>>;
            /**
             *See [`Pallet::kill`].
             */
            kill: TxDescriptor<Anonymize<I666bl2fqjkejo>>;
            /**
             *See [`Pallet::nudge_referendum`].
             */
            nudge_referendum: TxDescriptor<Anonymize<I666bl2fqjkejo>>;
            /**
             *See [`Pallet::one_fewer_deciding`].
             */
            one_fewer_deciding: TxDescriptor<Anonymize<Icbio0e1f0034b>>;
            /**
             *See [`Pallet::refund_submission_deposit`].
             */
            refund_submission_deposit: TxDescriptor<Anonymize<I666bl2fqjkejo>>;
            /**
             *See [`Pallet::set_metadata`].
             */
            set_metadata: TxDescriptor<Anonymize<Ifml0k0sf0mu2g>>;
        },
        {
            /**
             *A referendum has been submitted.
             */
            Submitted: PlainDescriptor<Anonymize<Idhr9v8mlnjej>>;
            /**
             *The decision deposit has been placed.
             */
            DecisionDepositPlaced: PlainDescriptor<Anonymize<I62nte77gksm0f>>;
            /**
             *The decision deposit has been refunded.
             */
            DecisionDepositRefunded: PlainDescriptor<Anonymize<I62nte77gksm0f>>;
            /**
             *A deposit has been slashaed.
             */
            DepositSlashed: PlainDescriptor<Anonymize<Id5fm4p8lj5qgi>>;
            /**
             *A referendum has moved into the deciding phase.
             */
            DecisionStarted: PlainDescriptor<Anonymize<I932allgc83a4a>>;
            /**
            
             */
            ConfirmStarted: PlainDescriptor<Anonymize<I666bl2fqjkejo>>;
            /**
            
             */
            ConfirmAborted: PlainDescriptor<Anonymize<I666bl2fqjkejo>>;
            /**
             *A referendum has ended its confirmation phase and is ready for approval.
             */
            Confirmed: PlainDescriptor<Anonymize<Ilhp45uime5tp>>;
            /**
             *A referendum has been approved and its proposal has been scheduled.
             */
            Approved: PlainDescriptor<Anonymize<I666bl2fqjkejo>>;
            /**
             *A proposal has been rejected by referendum.
             */
            Rejected: PlainDescriptor<Anonymize<Ilhp45uime5tp>>;
            /**
             *A referendum has been timed out without being decided.
             */
            TimedOut: PlainDescriptor<Anonymize<Ilhp45uime5tp>>;
            /**
             *A referendum has been cancelled.
             */
            Cancelled: PlainDescriptor<Anonymize<Ilhp45uime5tp>>;
            /**
             *A referendum has been killed.
             */
            Killed: PlainDescriptor<Anonymize<Ilhp45uime5tp>>;
            /**
             *The submission deposit has been refunded.
             */
            SubmissionDepositRefunded: PlainDescriptor<Anonymize<I62nte77gksm0f>>;
            /**
             *Metadata for a referendum has been set.
             */
            MetadataSet: PlainDescriptor<Anonymize<I50aq0q2l1cdkr>>;
            /**
             *Metadata for a referendum has been cleared.
             */
            MetadataCleared: PlainDescriptor<Anonymize<I50aq0q2l1cdkr>>;
        },
        {
            /**
             *Referendum is not ongoing.
             */
            NotOngoing: PlainDescriptor<undefined>;
            /**
             *Referendum's decision deposit is already paid.
             */
            HasDeposit: PlainDescriptor<undefined>;
            /**
             *The track identifier given was invalid.
             */
            BadTrack: PlainDescriptor<undefined>;
            /**
             *There are already a full complement of referenda in progress for this track.
             */
            Full: PlainDescriptor<undefined>;
            /**
             *The queue of the track is empty.
             */
            QueueEmpty: PlainDescriptor<undefined>;
            /**
             *The referendum index provided is invalid in this context.
             */
            BadReferendum: PlainDescriptor<undefined>;
            /**
             *There was nothing to do in the advancement.
             */
            NothingToDo: PlainDescriptor<undefined>;
            /**
             *No track exists for the proposal origin.
             */
            NoTrack: PlainDescriptor<undefined>;
            /**
             *Any deposit cannot be refunded until after the decision is over.
             */
            Unfinished: PlainDescriptor<undefined>;
            /**
             *The deposit refunder is not the depositor.
             */
            NoPermission: PlainDescriptor<undefined>;
            /**
             *The deposit cannot be refunded since none was made.
             */
            NoDeposit: PlainDescriptor<undefined>;
            /**
             *The referendum status is invalid for this operation.
             */
            BadStatus: PlainDescriptor<undefined>;
            /**
             *The preimage does not exist.
             */
            PreimageNotExist: PlainDescriptor<undefined>;
        },
        {
            /**
             * The minimum amount to be used as a deposit for a public referendum proposal.
             */
            SubmissionDeposit: PlainDescriptor<bigint>;
            /**
             * Maximum size of the referendum queue for a single track.
             */
            MaxQueued: PlainDescriptor<number>;
            /**
             * The number of blocks after submission that a referendum must begin being decided by.
             * Once this passes, then anyone may cancel the referendum.
             */
            UndecidingTimeout: PlainDescriptor<number>;
            /**
             * Quantization level for the referendum wakeup scheduler. A higher number will result in
             * fewer storage reads/writes needed for smaller voters, but also result in delays to the
             * automatic referendum status changes. Explicit servicing instructions are unaffected.
             */
            AlarmInterval: PlainDescriptor<number>;
            /**
             * Information concerning the different referendum tracks.
             */
            Tracks: PlainDescriptor<Anonymize<Ibafpkl9hhno69>>;
        }
    ];
    Whitelist: [
        {
            /**
            
             */
            WhitelistedCall: StorageDescriptor<[Key: Binary], undefined, true>;
        },
        {
            /**
             *See [`Pallet::whitelist_call`].
             */
            whitelist_call: TxDescriptor<Anonymize<I8413rb6im3iko>>;
            /**
             *See [`Pallet::remove_whitelisted_call`].
             */
            remove_whitelisted_call: TxDescriptor<Anonymize<I8413rb6im3iko>>;
            /**
             *See [`Pallet::dispatch_whitelisted_call`].
             */
            dispatch_whitelisted_call: TxDescriptor<Anonymize<Id3s9pakjjc472>>;
            /**
             *See [`Pallet::dispatch_whitelisted_call_with_preimage`].
             */
            dispatch_whitelisted_call_with_preimage: TxDescriptor<Anonymize<Idf7eras2rn4rj>>;
        },
        {
            /**
            
             */
            CallWhitelisted: PlainDescriptor<Anonymize<I8413rb6im3iko>>;
            /**
            
             */
            WhitelistedCallRemoved: PlainDescriptor<Anonymize<I8413rb6im3iko>>;
            /**
            
             */
            WhitelistedCallDispatched: PlainDescriptor<Anonymize<I7b8pe56shlide>>;
        },
        {
            /**
             *The preimage of the call hash could not be loaded.
             */
            UnavailablePreImage: PlainDescriptor<undefined>;
            /**
             *The call could not be decoded.
             */
            UndecodableCall: PlainDescriptor<undefined>;
            /**
             *The weight of the decoded call was higher than the witness.
             */
            InvalidCallWeightWitness: PlainDescriptor<undefined>;
            /**
             *The call was not whitelisted.
             */
            CallIsNotWhitelisted: PlainDescriptor<undefined>;
            /**
             *The call was already whitelisted; No-Op.
             */
            CallAlreadyWhitelisted: PlainDescriptor<undefined>;
        },
        {}
    ];
    Claims: [
        {
            /**
            
             */
            Claims: StorageDescriptor<[Key: Binary], bigint, true>;
            /**
            
             */
            Total: StorageDescriptor<[], bigint, false>;
            /**
             * Vesting schedule for a claim.
             * First balance is the total amount that should be held for vesting.
             * Second balance is how much should be unlocked per block.
             * The block number is when the vesting should start.
             */
            Vesting: StorageDescriptor<[Key: Binary], Anonymize<I2phecamkn3pej>, true>;
            /**
             * The statement kind that must be signed, if any.
             */
            Signing: StorageDescriptor<[Key: Binary], ClaimsStatementKind, true>;
            /**
             * Pre-claimed Ethereum accounts, by the Account ID that they are claimed to.
             */
            Preclaims: StorageDescriptor<[Key: SS58String], Binary, true>;
        },
        {
            /**
             *See [`Pallet::claim`].
             */
            claim: TxDescriptor<Anonymize<I1u3s4gbjnre15>>;
            /**
             *See [`Pallet::mint_claim`].
             */
            mint_claim: TxDescriptor<Anonymize<I20qiajmn4c5d4>>;
            /**
             *See [`Pallet::claim_attest`].
             */
            claim_attest: TxDescriptor<Anonymize<Ie3aplba76d794>>;
            /**
             *See [`Pallet::attest`].
             */
            attest: TxDescriptor<Anonymize<I1ntko0oih7v1a>>;
            /**
             *See [`Pallet::move_claim`].
             */
            move_claim: TxDescriptor<Anonymize<I193pigt6gtjff>>;
        },
        {
            /**
             *Someone claimed some DOTs.
             */
            Claimed: PlainDescriptor<Anonymize<Idhjiuhlaei3db>>;
        },
        {
            /**
             *Invalid Ethereum signature.
             */
            InvalidEthereumSignature: PlainDescriptor<undefined>;
            /**
             *Ethereum address has no claim.
             */
            SignerHasNoClaim: PlainDescriptor<undefined>;
            /**
             *Account ID sending transaction has no claim.
             */
            SenderHasNoClaim: PlainDescriptor<undefined>;
            /**
             *There's not enough in the pot to pay out some unvested amount. Generally implies a
             *logic error.
             */
            PotUnderflow: PlainDescriptor<undefined>;
            /**
             *A needed statement was not included.
             */
            InvalidStatement: PlainDescriptor<undefined>;
            /**
             *The account already has a vested balance.
             */
            VestedBalanceExists: PlainDescriptor<undefined>;
        },
        {
            /**
            
             */
            Prefix: PlainDescriptor<Binary>;
        }
    ];
    Vesting: [
        {
            /**
             * Information regarding the vesting of a given account.
             */
            Vesting: StorageDescriptor<[Key: SS58String], Anonymize<Ifble4juuml5ig>, true>;
            /**
             * Storage version of the pallet.
             *
             * New networks start with latest version, as determined by the genesis build.
             */
            StorageVersion: StorageDescriptor<[], VestingReleases, false>;
        },
        {
            /**
             *See [`Pallet::vest`].
             */
            vest: TxDescriptor<undefined>;
            /**
             *See [`Pallet::vest_other`].
             */
            vest_other: TxDescriptor<Anonymize<I29er5j74l8bu>>;
            /**
             *See [`Pallet::vested_transfer`].
             */
            vested_transfer: TxDescriptor<Anonymize<I9l9kkok4o3ekh>>;
            /**
             *See [`Pallet::force_vested_transfer`].
             */
            force_vested_transfer: TxDescriptor<Anonymize<I50ve0bbda0j1r>>;
            /**
             *See [`Pallet::merge_schedules`].
             */
            merge_schedules: TxDescriptor<Anonymize<Ict9ivhr2c5hv0>>;
        },
        {
            /**
             *The amount vested has been updated. This could indicate a change in funds available.
             *The balance given is the amount which is left unvested (and thus locked).
             */
            VestingUpdated: PlainDescriptor<Anonymize<Ievr89968437gm>>;
            /**
             *An \[account\] has become fully vested.
             */
            VestingCompleted: PlainDescriptor<Anonymize<Icbccs0ug47ilf>>;
        },
        {
            /**
             *The account given is not vesting.
             */
            NotVesting: PlainDescriptor<undefined>;
            /**
             *The account already has `MaxVestingSchedules` count of schedules and thus
             *cannot add another one. Consider merging existing schedules in order to add another.
             */
            AtMaxVestingSchedules: PlainDescriptor<undefined>;
            /**
             *Amount being transferred is too low to create a vesting schedule.
             */
            AmountLow: PlainDescriptor<undefined>;
            /**
             *An index was out of bounds of the vesting schedules.
             */
            ScheduleIndexOutOfBounds: PlainDescriptor<undefined>;
            /**
             *Failed to create a new schedule because some parameter was invalid.
             */
            InvalidScheduleParams: PlainDescriptor<undefined>;
        },
        {
            /**
             * The minimum amount transferred to call `vested_transfer`.
             */
            MinVestedTransfer: PlainDescriptor<bigint>;
            /**
            
             */
            MaxVestingSchedules: PlainDescriptor<number>;
        }
    ];
    Utility: [
        {},
        {
            /**
             *See [`Pallet::batch`].
             */
            batch: TxDescriptor<Anonymize<Id8ilk50mukg0o>>;
            /**
             *See [`Pallet::as_derivative`].
             */
            as_derivative: TxDescriptor<Anonymize<Ie36meht90lrma>>;
            /**
             *See [`Pallet::batch_all`].
             */
            batch_all: TxDescriptor<Anonymize<Id8ilk50mukg0o>>;
            /**
             *See [`Pallet::dispatch_as`].
             */
            dispatch_as: TxDescriptor<Anonymize<Ibb7qiar2nh5rh>>;
            /**
             *See [`Pallet::force_batch`].
             */
            force_batch: TxDescriptor<Anonymize<Id8ilk50mukg0o>>;
            /**
             *See [`Pallet::with_weight`].
             */
            with_weight: TxDescriptor<Anonymize<I6c37kkkbmesra>>;
        },
        {
            /**
             *Batch of dispatches did not complete fully. Index of first failing dispatch given, as
             *well as the error.
             */
            BatchInterrupted: PlainDescriptor<Anonymize<I6tn8e5lqr339o>>;
            /**
             *Batch of dispatches completed fully with no error.
             */
            BatchCompleted: PlainDescriptor<undefined>;
            /**
             *Batch of dispatches completed but has errors.
             */
            BatchCompletedWithErrors: PlainDescriptor<undefined>;
            /**
             *A single item within a Batch of dispatches has completed with no error.
             */
            ItemCompleted: PlainDescriptor<undefined>;
            /**
             *A single item within a Batch of dispatches has completed with error.
             */
            ItemFailed: PlainDescriptor<Anonymize<I11lb9o37qkk4f>>;
            /**
             *A call was dispatched.
             */
            DispatchedAs: PlainDescriptor<Anonymize<Ie5i8qqljk3tjb>>;
        },
        {
            /**
             *Too many calls batched.
             */
            TooManyCalls: PlainDescriptor<undefined>;
        },
        {
            /**
             * The limit on the number of batched calls.
             */
            batched_calls_limit: PlainDescriptor<number>;
        }
    ];
    Identity: [
        {
            /**
             * Information that is pertinent to identify the entity behind an account.
             *
             * TWOX-NOTE: OK ― `AccountId` is a secure hash.
             */
            IdentityOf: StorageDescriptor<[Key: SS58String], Anonymize<I60cr97f9of5s5>, true>;
            /**
             * The super-identity of an alternative "sub" identity together with its name, within that
             * context. If the account is not some other account's sub-identity, then just `None`.
             */
            SuperOf: StorageDescriptor<[Key: SS58String], Anonymize<Ib22937a5d3pt0>, true>;
            /**
             * Alternative "sub" identities of this account.
             *
             * The first item is the deposit, the second is a vector of the accounts.
             *
             * TWOX-NOTE: OK ― `AccountId` is a secure hash.
             */
            SubsOf: StorageDescriptor<[Key: SS58String], Anonymize<I4nfjdef0ibh44>, false>;
            /**
             * The set of registrars. Not expected to get very big as can only be added through a
             * special origin (likely a council motion).
             *
             * The index into this can be cast to `RegistrarIndex` to get a valid value.
             */
            Registrars: StorageDescriptor<[], Anonymize<I74af64m08r6as>, false>;
        },
        {
            /**
             *See [`Pallet::add_registrar`].
             */
            add_registrar: TxDescriptor<Anonymize<Ibsu2pfvipmui6>>;
            /**
             *See [`Pallet::set_identity`].
             */
            set_identity: TxDescriptor<Anonymize<I621gpns74tp1f>>;
            /**
             *See [`Pallet::set_subs`].
             */
            set_subs: TxDescriptor<Anonymize<I5100vdjbepcoj>>;
            /**
             *See [`Pallet::clear_identity`].
             */
            clear_identity: TxDescriptor<undefined>;
            /**
             *See [`Pallet::request_judgement`].
             */
            request_judgement: TxDescriptor<Anonymize<I9l2s4klu0831o>>;
            /**
             *See [`Pallet::cancel_request`].
             */
            cancel_request: TxDescriptor<Anonymize<I2ctrt5nqb8o7c>>;
            /**
             *See [`Pallet::set_fee`].
             */
            set_fee: TxDescriptor<Anonymize<I711qahikocb1c>>;
            /**
             *See [`Pallet::set_account_id`].
             */
            set_account_id: TxDescriptor<Anonymize<Idge7gk9m5car0>>;
            /**
             *See [`Pallet::set_fields`].
             */
            set_fields: TxDescriptor<Anonymize<Id6gojh30v9ib2>>;
            /**
             *See [`Pallet::provide_judgement`].
             */
            provide_judgement: TxDescriptor<Anonymize<I2g5s5rvm0mfuf>>;
            /**
             *See [`Pallet::kill_identity`].
             */
            kill_identity: TxDescriptor<Anonymize<I29er5j74l8bu>>;
            /**
             *See [`Pallet::add_sub`].
             */
            add_sub: TxDescriptor<Anonymize<Iclf5v4qsadc12>>;
            /**
             *See [`Pallet::rename_sub`].
             */
            rename_sub: TxDescriptor<Anonymize<Iclf5v4qsadc12>>;
            /**
             *See [`Pallet::remove_sub`].
             */
            remove_sub: TxDescriptor<Anonymize<Ifcc5t6ed1elfd>>;
            /**
             *See [`Pallet::quit_sub`].
             */
            quit_sub: TxDescriptor<undefined>;
        },
        {
            /**
             *A name was set or reset (which will remove all judgements).
             */
            IdentitySet: PlainDescriptor<Anonymize<I4cbvqmqadhrea>>;
            /**
             *A name was cleared, and the given balance returned.
             */
            IdentityCleared: PlainDescriptor<Anonymize<Iep1lmt6q3s6r3>>;
            /**
             *A name was removed and the given balance slashed.
             */
            IdentityKilled: PlainDescriptor<Anonymize<Iep1lmt6q3s6r3>>;
            /**
             *A judgement was asked from a registrar.
             */
            JudgementRequested: PlainDescriptor<Anonymize<I1fac16213rie2>>;
            /**
             *A judgement request was retracted.
             */
            JudgementUnrequested: PlainDescriptor<Anonymize<I1fac16213rie2>>;
            /**
             *A judgement was given by a registrar.
             */
            JudgementGiven: PlainDescriptor<Anonymize<Ifjt77oc391o43>>;
            /**
             *A registrar was added.
             */
            RegistrarAdded: PlainDescriptor<Anonymize<Itvt1jsipv0lc>>;
            /**
             *A sub-identity was added to an identity and the deposit paid.
             */
            SubIdentityAdded: PlainDescriptor<Anonymize<Ick3mveut33f44>>;
            /**
             *A sub-identity was removed from an identity and the deposit freed.
             */
            SubIdentityRemoved: PlainDescriptor<Anonymize<Ick3mveut33f44>>;
            /**
             *A sub-identity was cleared, and the given deposit repatriated from the
             *main identity account to the sub-identity account.
             */
            SubIdentityRevoked: PlainDescriptor<Anonymize<Ick3mveut33f44>>;
        },
        {
            /**
             *Too many subs-accounts.
             */
            TooManySubAccounts: PlainDescriptor<undefined>;
            /**
             *Account isn't found.
             */
            NotFound: PlainDescriptor<undefined>;
            /**
             *Account isn't named.
             */
            NotNamed: PlainDescriptor<undefined>;
            /**
             *Empty index.
             */
            EmptyIndex: PlainDescriptor<undefined>;
            /**
             *Fee is changed.
             */
            FeeChanged: PlainDescriptor<undefined>;
            /**
             *No identity found.
             */
            NoIdentity: PlainDescriptor<undefined>;
            /**
             *Sticky judgement.
             */
            StickyJudgement: PlainDescriptor<undefined>;
            /**
             *Judgement given.
             */
            JudgementGiven: PlainDescriptor<undefined>;
            /**
             *Invalid judgement.
             */
            InvalidJudgement: PlainDescriptor<undefined>;
            /**
             *The index is invalid.
             */
            InvalidIndex: PlainDescriptor<undefined>;
            /**
             *The target is invalid.
             */
            InvalidTarget: PlainDescriptor<undefined>;
            /**
             *Too many additional fields.
             */
            TooManyFields: PlainDescriptor<undefined>;
            /**
             *Maximum amount of registrars reached. Cannot add any more.
             */
            TooManyRegistrars: PlainDescriptor<undefined>;
            /**
             *Account ID is already named.
             */
            AlreadyClaimed: PlainDescriptor<undefined>;
            /**
             *Sender is not a sub-account.
             */
            NotSub: PlainDescriptor<undefined>;
            /**
             *Sub-account isn't owned by sender.
             */
            NotOwned: PlainDescriptor<undefined>;
            /**
             *The provided judgement was for a different identity.
             */
            JudgementForDifferentIdentity: PlainDescriptor<undefined>;
            /**
             *Error that occurs when there is an issue paying for judgement.
             */
            JudgementPaymentFailed: PlainDescriptor<undefined>;
        },
        {
            /**
             * The amount held on deposit for a registered identity
             */
            BasicDeposit: PlainDescriptor<bigint>;
            /**
             * The amount held on deposit per additional field for a registered identity.
             */
            FieldDeposit: PlainDescriptor<bigint>;
            /**
             * The amount held on deposit for a registered subaccount. This should account for the fact
             * that one storage item's value will increase by the size of an account ID, and there will
             * be another trie item whose value is the size of an account ID plus 32 bytes.
             */
            SubAccountDeposit: PlainDescriptor<bigint>;
            /**
             * The maximum number of sub-accounts allowed per identified account.
             */
            MaxSubAccounts: PlainDescriptor<number>;
            /**
             * Maximum number of additional fields that may be stored in an ID. Needed to bound the I/O
             * required to access an identity, but can be pretty high.
             */
            MaxAdditionalFields: PlainDescriptor<number>;
            /**
             * Maxmimum number of registrars allowed in the system. Needed to bound the complexity
             * of, e.g., updating judgements.
             */
            MaxRegistrars: PlainDescriptor<number>;
        }
    ];
    Proxy: [
        {
            /**
             * The set of account proxies. Maps the account which has delegated to the accounts
             * which are being delegated to, together with the amount held on deposit.
             */
            Proxies: StorageDescriptor<[Key: SS58String], Anonymize<If0n3k77qd4p7k>, false>;
            /**
             * The announcements made by the proxy (key).
             */
            Announcements: StorageDescriptor<[Key: SS58String], Anonymize<I3tjio59962rg2>, false>;
        },
        {
            /**
             *See [`Pallet::proxy`].
             */
            proxy: TxDescriptor<Anonymize<I55q6ritdd2v83>>;
            /**
             *See [`Pallet::add_proxy`].
             */
            add_proxy: TxDescriptor<Anonymize<Iaaog12m0bl04j>>;
            /**
             *See [`Pallet::remove_proxy`].
             */
            remove_proxy: TxDescriptor<Anonymize<Iaaog12m0bl04j>>;
            /**
             *See [`Pallet::remove_proxies`].
             */
            remove_proxies: TxDescriptor<undefined>;
            /**
             *See [`Pallet::create_pure`].
             */
            create_pure: TxDescriptor<Anonymize<I6l2ag419uso4i>>;
            /**
             *See [`Pallet::kill_pure`].
             */
            kill_pure: TxDescriptor<Anonymize<I7304brn0jssvr>>;
            /**
             *See [`Pallet::announce`].
             */
            announce: TxDescriptor<Anonymize<Id3bpmvju2iqi5>>;
            /**
             *See [`Pallet::remove_announcement`].
             */
            remove_announcement: TxDescriptor<Anonymize<Id3bpmvju2iqi5>>;
            /**
             *See [`Pallet::reject_announcement`].
             */
            reject_announcement: TxDescriptor<Anonymize<Ietdab69eu3c4e>>;
            /**
             *See [`Pallet::proxy_announced`].
             */
            proxy_announced: TxDescriptor<Anonymize<Ic91pvvaf9eh9k>>;
        },
        {
            /**
             *A proxy was executed correctly, with the given.
             */
            ProxyExecuted: PlainDescriptor<Anonymize<Ie5i8qqljk3tjb>>;
            /**
             *A pure account has been created by new proxy with given
             *disambiguation index and proxy type.
             */
            PureCreated: PlainDescriptor<Anonymize<I180p9c978rp4d>>;
            /**
             *An announcement was placed to make a call in the future.
             */
            Announced: PlainDescriptor<Anonymize<Idbjbboh0q507r>>;
            /**
             *A proxy was added.
             */
            ProxyAdded: PlainDescriptor<Anonymize<I94ud6o1n6v0n8>>;
            /**
             *A proxy was removed.
             */
            ProxyRemoved: PlainDescriptor<Anonymize<I94ud6o1n6v0n8>>;
        },
        {
            /**
             *There are too many proxies registered or too many announcements pending.
             */
            TooMany: PlainDescriptor<undefined>;
            /**
             *Proxy registration not found.
             */
            NotFound: PlainDescriptor<undefined>;
            /**
             *Sender is not a proxy of the account to be proxied.
             */
            NotProxy: PlainDescriptor<undefined>;
            /**
             *A call which is incompatible with the proxy type's filter was attempted.
             */
            Unproxyable: PlainDescriptor<undefined>;
            /**
             *Account is already a proxy.
             */
            Duplicate: PlainDescriptor<undefined>;
            /**
             *Call may not be made by proxy because it may escalate its privileges.
             */
            NoPermission: PlainDescriptor<undefined>;
            /**
             *Announcement, if made at all, was made too recently.
             */
            Unannounced: PlainDescriptor<undefined>;
            /**
             *Cannot add self as proxy.
             */
            NoSelfProxy: PlainDescriptor<undefined>;
        },
        {
            /**
             * The base amount of currency needed to reserve for creating a proxy.
             *
             * This is held for an additional storage item whose value size is
             * `sizeof(Balance)` bytes and whose key size is `sizeof(AccountId)` bytes.
             */
            ProxyDepositBase: PlainDescriptor<bigint>;
            /**
             * The amount of currency needed per proxy added.
             *
             * This is held for adding 32 bytes plus an instance of `ProxyType` more into a
             * pre-existing storage value. Thus, when configuring `ProxyDepositFactor` one should take
             * into account `32 + proxy_type.encode().len()` bytes of data.
             */
            ProxyDepositFactor: PlainDescriptor<bigint>;
            /**
             * The maximum amount of proxies allowed for a single account.
             */
            MaxProxies: PlainDescriptor<number>;
            /**
             * The maximum amount of time-delayed announcements that are allowed to be pending.
             */
            MaxPending: PlainDescriptor<number>;
            /**
             * The base amount of currency needed to reserve for creating an announcement.
             *
             * This is held when a new storage item holding a `Balance` is created (typically 16
             * bytes).
             */
            AnnouncementDepositBase: PlainDescriptor<bigint>;
            /**
             * The amount of currency needed per announcement made.
             *
             * This is held for adding an `AccountId`, `Hash` and `BlockNumber` (typically 68 bytes)
             * into a pre-existing storage value.
             */
            AnnouncementDepositFactor: PlainDescriptor<bigint>;
        }
    ];
    Multisig: [
        {
            /**
             * The set of open multisig operations.
             */
            Multisigs: StorageDescriptor<Anonymize<I73gble6tmb52f>, Anonymize<Iag146hmjgqfgj>, true>;
        },
        {
            /**
             *See [`Pallet::as_multi_threshold_1`].
             */
            as_multi_threshold_1: TxDescriptor<Anonymize<I9qeq6jurh88f2>>;
            /**
             *See [`Pallet::as_multi`].
             */
            as_multi: TxDescriptor<Anonymize<I8aql6ho3v5akd>>;
            /**
             *See [`Pallet::approve_as_multi`].
             */
            approve_as_multi: TxDescriptor<Anonymize<I349bg0i7n8ohu>>;
            /**
             *See [`Pallet::cancel_as_multi`].
             */
            cancel_as_multi: TxDescriptor<Anonymize<I8plicv234mqe5>>;
        },
        {
            /**
             *A new multisig operation has begun.
             */
            NewMultisig: PlainDescriptor<Anonymize<Ibvv58de7m7rsi>>;
            /**
             *A multisig operation has been approved by someone.
             */
            MultisigApproval: PlainDescriptor<Anonymize<I4uo2dg1jvbdtg>>;
            /**
             *A multisig operation has been executed.
             */
            MultisigExecuted: PlainDescriptor<Anonymize<Ifbo6gts4g8u33>>;
            /**
             *A multisig operation has been cancelled.
             */
            MultisigCancelled: PlainDescriptor<Anonymize<I82jp3a00f0f8k>>;
        },
        {
            /**
             *Threshold must be 2 or greater.
             */
            MinimumThreshold: PlainDescriptor<undefined>;
            /**
             *Call is already approved by this signatory.
             */
            AlreadyApproved: PlainDescriptor<undefined>;
            /**
             *Call doesn't need any (more) approvals.
             */
            NoApprovalsNeeded: PlainDescriptor<undefined>;
            /**
             *There are too few signatories in the list.
             */
            TooFewSignatories: PlainDescriptor<undefined>;
            /**
             *There are too many signatories in the list.
             */
            TooManySignatories: PlainDescriptor<undefined>;
            /**
             *The signatories were provided out of order; they should be ordered.
             */
            SignatoriesOutOfOrder: PlainDescriptor<undefined>;
            /**
             *The sender was contained in the other signatories; it shouldn't be.
             */
            SenderInSignatories: PlainDescriptor<undefined>;
            /**
             *Multisig operation not found when attempting to cancel.
             */
            NotFound: PlainDescriptor<undefined>;
            /**
             *Only the account that originally created the multisig is able to cancel it.
             */
            NotOwner: PlainDescriptor<undefined>;
            /**
             *No timepoint was given, yet the multisig operation is already underway.
             */
            NoTimepoint: PlainDescriptor<undefined>;
            /**
             *A different timepoint was given to the multisig operation that is underway.
             */
            WrongTimepoint: PlainDescriptor<undefined>;
            /**
             *A timepoint was given, yet no multisig operation is underway.
             */
            UnexpectedTimepoint: PlainDescriptor<undefined>;
            /**
             *The maximum weight information provided was too low.
             */
            MaxWeightTooLow: PlainDescriptor<undefined>;
            /**
             *The data to be stored is already stored.
             */
            AlreadyStored: PlainDescriptor<undefined>;
        },
        {
            /**
             * The base amount of currency needed to reserve for creating a multisig execution or to
             * store a dispatch call for later.
             *
             * This is held for an additional storage item whose value size is
             * `4 + sizeof((BlockNumber, Balance, AccountId))` bytes and whose key size is
             * `32 + sizeof(AccountId)` bytes.
             */
            DepositBase: PlainDescriptor<bigint>;
            /**
             * The amount of currency needed per unit threshold when creating a multisig execution.
             *
             * This is held for adding 32 bytes more into a pre-existing storage value.
             */
            DepositFactor: PlainDescriptor<bigint>;
            /**
             * The maximum amount of signatories allowed in the multisig.
             */
            MaxSignatories: PlainDescriptor<number>;
        }
    ];
    Bounties: [
        {
            /**
             * Number of bounty proposals that have been made.
             */
            BountyCount: StorageDescriptor<[], number, false>;
            /**
             * Bounties that have been made.
             */
            Bounties: StorageDescriptor<[Key: number], Anonymize<Ic28sp53lp2v4a>, true>;
            /**
             * The description of each bounty.
             */
            BountyDescriptions: StorageDescriptor<[Key: number], Binary, true>;
            /**
             * Bounty indices that have been approved but not yet funded.
             */
            BountyApprovals: StorageDescriptor<[], Anonymize<Icgljjb6j82uhn>, false>;
        },
        {
            /**
             *See [`Pallet::propose_bounty`].
             */
            propose_bounty: TxDescriptor<Anonymize<I2a839vbf5817q>>;
            /**
             *See [`Pallet::approve_bounty`].
             */
            approve_bounty: TxDescriptor<Anonymize<Ia9p5bg6p18r0i>>;
            /**
             *See [`Pallet::propose_curator`].
             */
            propose_curator: TxDescriptor<Anonymize<I86gbm3avnuhcj>>;
            /**
             *See [`Pallet::unassign_curator`].
             */
            unassign_curator: TxDescriptor<Anonymize<Ia9p5bg6p18r0i>>;
            /**
             *See [`Pallet::accept_curator`].
             */
            accept_curator: TxDescriptor<Anonymize<Ia9p5bg6p18r0i>>;
            /**
             *See [`Pallet::award_bounty`].
             */
            award_bounty: TxDescriptor<Anonymize<I9khudebied2et>>;
            /**
             *See [`Pallet::claim_bounty`].
             */
            claim_bounty: TxDescriptor<Anonymize<Ia9p5bg6p18r0i>>;
            /**
             *See [`Pallet::close_bounty`].
             */
            close_bounty: TxDescriptor<Anonymize<Ia9p5bg6p18r0i>>;
            /**
             *See [`Pallet::extend_bounty_expiry`].
             */
            extend_bounty_expiry: TxDescriptor<Anonymize<I90n6nnkpdahrh>>;
        },
        {
            /**
             *New bounty proposal.
             */
            BountyProposed: PlainDescriptor<Anonymize<I666bl2fqjkejo>>;
            /**
             *A bounty proposal was rejected; funds were slashed.
             */
            BountyRejected: PlainDescriptor<Anonymize<Id9idaj83175f9>>;
            /**
             *A bounty proposal is funded and became active.
             */
            BountyBecameActive: PlainDescriptor<Anonymize<I666bl2fqjkejo>>;
            /**
             *A bounty is awarded to a beneficiary.
             */
            BountyAwarded: PlainDescriptor<Anonymize<Ie1semicfuv5uu>>;
            /**
             *A bounty is claimed by beneficiary.
             */
            BountyClaimed: PlainDescriptor<Anonymize<If25fjs9o37co1>>;
            /**
             *A bounty is cancelled.
             */
            BountyCanceled: PlainDescriptor<Anonymize<I666bl2fqjkejo>>;
            /**
             *A bounty expiry is extended.
             */
            BountyExtended: PlainDescriptor<Anonymize<I666bl2fqjkejo>>;
            /**
             *A bounty is approved.
             */
            BountyApproved: PlainDescriptor<Anonymize<I666bl2fqjkejo>>;
            /**
             *A bounty curator is proposed.
             */
            CuratorProposed: PlainDescriptor<Anonymize<I70sc1pdo8vtos>>;
            /**
             *A bounty curator is unassigned.
             */
            CuratorUnassigned: PlainDescriptor<Anonymize<Ia9p5bg6p18r0i>>;
            /**
             *A bounty curator is accepted.
             */
            CuratorAccepted: PlainDescriptor<Anonymize<I70sc1pdo8vtos>>;
        },
        {
            /**
             *Proposer's balance is too low.
             */
            InsufficientProposersBalance: PlainDescriptor<undefined>;
            /**
             *No proposal or bounty at that index.
             */
            InvalidIndex: PlainDescriptor<undefined>;
            /**
             *The reason given is just too big.
             */
            ReasonTooBig: PlainDescriptor<undefined>;
            /**
             *The bounty status is unexpected.
             */
            UnexpectedStatus: PlainDescriptor<undefined>;
            /**
             *Require bounty curator.
             */
            RequireCurator: PlainDescriptor<undefined>;
            /**
             *Invalid bounty value.
             */
            InvalidValue: PlainDescriptor<undefined>;
            /**
             *Invalid bounty fee.
             */
            InvalidFee: PlainDescriptor<undefined>;
            /**
             *A bounty payout is pending.
             *To cancel the bounty, you must unassign and slash the curator.
             */
            PendingPayout: PlainDescriptor<undefined>;
            /**
             *The bounties cannot be claimed/closed because it's still in the countdown period.
             */
            Premature: PlainDescriptor<undefined>;
            /**
             *The bounty cannot be closed because it has active child bounties.
             */
            HasActiveChildBounty: PlainDescriptor<undefined>;
            /**
             *Too many approvals are already queued.
             */
            TooManyQueued: PlainDescriptor<undefined>;
        },
        {
            /**
             * The amount held on deposit for placing a bounty proposal.
             */
            BountyDepositBase: PlainDescriptor<bigint>;
            /**
             * The delay period for which a bounty beneficiary need to wait before claim the payout.
             */
            BountyDepositPayoutDelay: PlainDescriptor<number>;
            /**
             * Bounty duration in blocks.
             */
            BountyUpdatePeriod: PlainDescriptor<number>;
            /**
             * The curator deposit is calculated as a percentage of the curator fee.
             *
             * This deposit has optional upper and lower bounds with `CuratorDepositMax` and
             * `CuratorDepositMin`.
             */
            CuratorDepositMultiplier: PlainDescriptor<number>;
            /**
             * Maximum amount of funds that should be placed in a deposit for making a proposal.
             */
            CuratorDepositMax: PlainDescriptor<Anonymize<I35p85j063s0il>>;
            /**
             * Minimum amount of funds that should be placed in a deposit for making a proposal.
             */
            CuratorDepositMin: PlainDescriptor<Anonymize<I35p85j063s0il>>;
            /**
             * Minimum value for a bounty.
             */
            BountyValueMinimum: PlainDescriptor<bigint>;
            /**
             * The amount held on deposit per byte within the tip report reason or bounty description.
             */
            DataDepositPerByte: PlainDescriptor<bigint>;
            /**
             * Maximum acceptable reason length.
             *
             * Benchmarks depend on this value, be sure to update weights file when changing this value
             */
            MaximumReasonLength: PlainDescriptor<number>;
        }
    ];
    ChildBounties: [
        {
            /**
             * Number of total child bounties.
             */
            ChildBountyCount: StorageDescriptor<[], number, false>;
            /**
             * Number of child bounties per parent bounty.
             * Map of parent bounty index to number of child bounties.
             */
            ParentChildBounties: StorageDescriptor<[Key: number], number, false>;
            /**
             * Child bounties that have been added.
             */
            ChildBounties: StorageDescriptor<Anonymize<I5g2vv0ckl2m8b>, Anonymize<Idvn49j11itec9>, true>;
            /**
             * The description of each child-bounty.
             */
            ChildBountyDescriptions: StorageDescriptor<[Key: number], Binary, true>;
            /**
             * The cumulative child-bounty curator fee for each parent bounty.
             */
            ChildrenCuratorFees: StorageDescriptor<[Key: number], bigint, false>;
        },
        {
            /**
             *See [`Pallet::add_child_bounty`].
             */
            add_child_bounty: TxDescriptor<Anonymize<I8mk5kjgn02hi8>>;
            /**
             *See [`Pallet::propose_curator`].
             */
            propose_curator: TxDescriptor<Anonymize<I113qogfj9ii7a>>;
            /**
             *See [`Pallet::accept_curator`].
             */
            accept_curator: TxDescriptor<Anonymize<I2gr10p66od9ch>>;
            /**
             *See [`Pallet::unassign_curator`].
             */
            unassign_curator: TxDescriptor<Anonymize<I2gr10p66od9ch>>;
            /**
             *See [`Pallet::award_child_bounty`].
             */
            award_child_bounty: TxDescriptor<Anonymize<I6okbrc1o6b331>>;
            /**
             *See [`Pallet::claim_child_bounty`].
             */
            claim_child_bounty: TxDescriptor<Anonymize<I2gr10p66od9ch>>;
            /**
             *See [`Pallet::close_child_bounty`].
             */
            close_child_bounty: TxDescriptor<Anonymize<I2gr10p66od9ch>>;
        },
        {
            /**
             *A child-bounty is added.
             */
            Added: PlainDescriptor<Anonymize<I60p8l86a8cm59>>;
            /**
             *A child-bounty is awarded to a beneficiary.
             */
            Awarded: PlainDescriptor<Anonymize<I3m3sk2lgcabvp>>;
            /**
             *A child-bounty is claimed by beneficiary.
             */
            Claimed: PlainDescriptor<Anonymize<I5pf572duh4oeg>>;
            /**
             *A child-bounty is cancelled.
             */
            Canceled: PlainDescriptor<Anonymize<I60p8l86a8cm59>>;
        },
        {
            /**
             *The parent bounty is not in active state.
             */
            ParentBountyNotActive: PlainDescriptor<undefined>;
            /**
             *The bounty balance is not enough to add new child-bounty.
             */
            InsufficientBountyBalance: PlainDescriptor<undefined>;
            /**
             *Number of child bounties exceeds limit `MaxActiveChildBountyCount`.
             */
            TooManyChildBounties: PlainDescriptor<undefined>;
        },
        {
            /**
             * Maximum number of child bounties that can be added to a parent bounty.
             */
            MaxActiveChildBountyCount: PlainDescriptor<number>;
            /**
             * Minimum value for a child-bounty.
             */
            ChildBountyValueMinimum: PlainDescriptor<bigint>;
        }
    ];
    ElectionProviderMultiPhase: [
        {
            /**
             * Internal counter for the number of rounds.
             *
             * This is useful for de-duplication of transactions submitted to the pool, and general
             * diagnostics of the pallet.
             *
             * This is merely incremented once per every time that an upstream `elect` is called.
             */
            Round: StorageDescriptor<[], number, false>;
            /**
             * Current phase.
             */
            CurrentPhase: StorageDescriptor<[], ElectionProviderMultiPhasePhase, false>;
            /**
             * Current best solution, signed or unsigned, queued to be returned upon `elect`.
             *
             * Always sorted by score.
             */
            QueuedSolution: StorageDescriptor<[], Anonymize<Ia5nfh4hon3go3>, true>;
            /**
             * Snapshot data of the round.
             *
             * This is created at the beginning of the signed phase and cleared upon calling `elect`.
             */
            Snapshot: StorageDescriptor<[], Anonymize<Ia7o65280hur3p>, true>;
            /**
             * Desired number of targets to elect for this round.
             *
             * Only exists when [`Snapshot`] is present.
             */
            DesiredTargets: StorageDescriptor<[], number, true>;
            /**
             * The metadata of the [`RoundSnapshot`]
             *
             * Only exists when [`Snapshot`] is present.
             */
            SnapshotMetadata: StorageDescriptor<[], Anonymize<Iasd2iat48n080>, true>;
            /**
             * The next index to be assigned to an incoming signed submission.
             *
             * Every accepted submission is assigned a unique index; that index is bound to that particular
             * submission for the duration of the election. On election finalization, the next index is
             * reset to 0.
             *
             * We can't just use `SignedSubmissionIndices.len()`, because that's a bounded set; past its
             * capacity, it will simply saturate. We can't just iterate over `SignedSubmissionsMap`,
             * because iteration is slow. Instead, we store the value here.
             */
            SignedSubmissionNextIndex: StorageDescriptor<[], number, false>;
            /**
             * A sorted, bounded vector of `(score, block_number, index)`, where each `index` points to a
             * value in `SignedSubmissions`.
             *
             * We never need to process more than a single signed submission at a time. Signed submissions
             * can be quite large, so we're willing to pay the cost of multiple database accesses to access
             * them one at a time instead of reading and decoding all of them at once.
             */
            SignedSubmissionIndices: StorageDescriptor<[], Anonymize<Ic8d01sg6acf60>, false>;
            /**
             * Unchecked, signed solutions.
             *
             * Together with `SubmissionIndices`, this stores a bounded set of `SignedSubmissions` while
             * allowing us to keep only a single one in memory at a time.
             *
             * Twox note: the key of the map is an auto-incrementing index which users cannot inspect or
             * affect; we shouldn't need a cryptographically secure hasher.
             */
            SignedSubmissionsMap: StorageDescriptor<[Key: number], Anonymize<Irl37q7erstrb>, true>;
            /**
             * The minimum score that each 'untrusted' solution must attain in order to be considered
             * feasible.
             *
             * Can be set via `set_minimum_untrusted_score`.
             */
            MinimumUntrustedScore: StorageDescriptor<[], Anonymize<I8s6n43okuj2b1>, true>;
        },
        {
            /**
             *See [`Pallet::submit_unsigned`].
             */
            submit_unsigned: TxDescriptor<Anonymize<I31k9f0jol8ko4>>;
            /**
             *See [`Pallet::set_minimum_untrusted_score`].
             */
            set_minimum_untrusted_score: TxDescriptor<Anonymize<I80q14um2s2ckg>>;
            /**
             *See [`Pallet::set_emergency_election_result`].
             */
            set_emergency_election_result: TxDescriptor<Anonymize<I5qs1t1erfi7u8>>;
            /**
             *See [`Pallet::submit`].
             */
            submit: TxDescriptor<Anonymize<I9et13knvdvgpb>>;
            /**
             *See [`Pallet::governance_fallback`].
             */
            governance_fallback: TxDescriptor<Anonymize<Ifsme8miqq9006>>;
        },
        {
            /**
             *A solution was stored with the given compute.
             *
             *The `origin` indicates the origin of the solution. If `origin` is `Some(AccountId)`,
             *the stored solution was submited in the signed phase by a miner with the `AccountId`.
             *Otherwise, the solution was stored either during the unsigned phase or by
             *`T::ForceOrigin`. The `bool` is `true` when a previous solution was ejected to make
             *room for this one.
             */
            SolutionStored: PlainDescriptor<Anonymize<I5an5igf3n0vgh>>;
            /**
             *The election has been finalized, with the given computation and score.
             */
            ElectionFinalized: PlainDescriptor<Anonymize<I1rd7gkt317ndg>>;
            /**
             *An election failed.
             *
             *Not much can be said about which computes failed in the process.
             */
            ElectionFailed: PlainDescriptor<undefined>;
            /**
             *An account has been rewarded for their signed submission being finalized.
             */
            Rewarded: PlainDescriptor<Anonymize<I7j4m7a3pkvsf4>>;
            /**
             *An account has been slashed for submitting an invalid signed submission.
             */
            Slashed: PlainDescriptor<Anonymize<I7j4m7a3pkvsf4>>;
            /**
             *There was a phase transition in a given round.
             */
            PhaseTransitioned: PlainDescriptor<Anonymize<Icrg5eih8vnokr>>;
        },
        {
            /**
             *Submission was too early.
             */
            PreDispatchEarlySubmission: PlainDescriptor<undefined>;
            /**
             *Wrong number of winners presented.
             */
            PreDispatchWrongWinnerCount: PlainDescriptor<undefined>;
            /**
             *Submission was too weak, score-wise.
             */
            PreDispatchWeakSubmission: PlainDescriptor<undefined>;
            /**
             *The queue was full, and the solution was not better than any of the existing ones.
             */
            SignedQueueFull: PlainDescriptor<undefined>;
            /**
             *The origin failed to pay the deposit.
             */
            SignedCannotPayDeposit: PlainDescriptor<undefined>;
            /**
             *Witness data to dispatchable is invalid.
             */
            SignedInvalidWitness: PlainDescriptor<undefined>;
            /**
             *The signed submission consumes too much weight
             */
            SignedTooMuchWeight: PlainDescriptor<undefined>;
            /**
             *OCW submitted solution for wrong round
             */
            OcwCallWrongEra: PlainDescriptor<undefined>;
            /**
             *Snapshot metadata should exist but didn't.
             */
            MissingSnapshotMetadata: PlainDescriptor<undefined>;
            /**
             *`Self::insert_submission` returned an invalid index.
             */
            InvalidSubmissionIndex: PlainDescriptor<undefined>;
            /**
             *The call is not allowed at this point.
             */
            CallNotAllowed: PlainDescriptor<undefined>;
            /**
             *The fallback failed
             */
            FallbackFailed: PlainDescriptor<undefined>;
            /**
             *Some bound not met
             */
            BoundNotMet: PlainDescriptor<undefined>;
            /**
             *Submitted solution has too many winners
             */
            TooManyWinners: PlainDescriptor<undefined>;
        },
        {
            /**
             * Duration of the unsigned phase.
             */
            UnsignedPhase: PlainDescriptor<number>;
            /**
             * Duration of the signed phase.
             */
            SignedPhase: PlainDescriptor<number>;
            /**
             * The minimum amount of improvement to the solution score that defines a solution as
             * "better" in the Signed phase.
             */
            BetterSignedThreshold: PlainDescriptor<number>;
            /**
             * The minimum amount of improvement to the solution score that defines a solution as
             * "better" in the Unsigned phase.
             */
            BetterUnsignedThreshold: PlainDescriptor<number>;
            /**
             * The repeat threshold of the offchain worker.
             *
             * For example, if it is 5, that means that at least 5 blocks will elapse between attempts
             * to submit the worker's solution.
             */
            OffchainRepeat: PlainDescriptor<number>;
            /**
             * The priority of the unsigned transaction submitted in the unsigned-phase
             */
            MinerTxPriority: PlainDescriptor<bigint>;
            /**
             * Maximum number of signed submissions that can be queued.
             *
             * It is best to avoid adjusting this during an election, as it impacts downstream data
             * structures. In particular, `SignedSubmissionIndices<T>` is bounded on this value. If you
             * update this value during an election, you _must_ ensure that
             * `SignedSubmissionIndices.len()` is less than or equal to the new value. Otherwise,
             * attempts to submit new solutions may cause a runtime panic.
             */
            SignedMaxSubmissions: PlainDescriptor<number>;
            /**
             * Maximum weight of a signed solution.
             *
             * If [`Config::MinerConfig`] is being implemented to submit signed solutions (outside of
             * this pallet), then [`MinerConfig::solution_weight`] is used to compare against
             * this value.
             */
            SignedMaxWeight: PlainDescriptor<Anonymize<I4q39t5hn830vp>>;
            /**
             * The maximum amount of unchecked solutions to refund the call fee for.
             */
            SignedMaxRefunds: PlainDescriptor<number>;
            /**
             * Base reward for a signed solution
             */
            SignedRewardBase: PlainDescriptor<bigint>;
            /**
             * Per-byte deposit for a signed solution.
             */
            SignedDepositByte: PlainDescriptor<bigint>;
            /**
             * Per-weight deposit for a signed solution.
             */
            SignedDepositWeight: PlainDescriptor<bigint>;
            /**
             * The maximum number of winners that can be elected by this `ElectionProvider`
             * implementation.
             *
             * Note: This must always be greater or equal to `T::DataProvider::desired_targets()`.
             */
            MaxWinners: PlainDescriptor<number>;
            /**
            
             */
            MinerMaxLength: PlainDescriptor<number>;
            /**
            
             */
            MinerMaxWeight: PlainDescriptor<Anonymize<I4q39t5hn830vp>>;
            /**
            
             */
            MinerMaxVotesPerVoter: PlainDescriptor<number>;
            /**
            
             */
            MinerMaxWinners: PlainDescriptor<number>;
        }
    ];
    VoterList: [
        {
            /**
             * A single node, within some bag.
             *
             * Nodes store links forward and back within their respective bags.
             */
            ListNodes: StorageDescriptor<[Key: SS58String], Anonymize<Ic5t26f9cp3tvk>, true>;
            /**
             *Counter for the related counted storage map
             */
            CounterForListNodes: StorageDescriptor<[], number, false>;
            /**
             * A bag stored in storage.
             *
             * Stores a `Bag` struct, which stores head and tail pointers to itself.
             */
            ListBags: StorageDescriptor<[Key: bigint], Anonymize<I39k39h6vu4hbq>, true>;
        },
        {
            /**
             *See [`Pallet::rebag`].
             */
            rebag: TxDescriptor<Anonymize<Iqk00vc9d6173>>;
            /**
             *See [`Pallet::put_in_front_of`].
             */
            put_in_front_of: TxDescriptor<Anonymize<Idg844jjtqnc9b>>;
            /**
             *See [`Pallet::put_in_front_of_other`].
             */
            put_in_front_of_other: TxDescriptor<Anonymize<Ic87kbtabpr82b>>;
        },
        {
            /**
             *Moved an account from one bag to another.
             */
            Rebagged: PlainDescriptor<Anonymize<I37454vatvmm1l>>;
            /**
             *Updated the score of some account to the given amount.
             */
            ScoreUpdated: PlainDescriptor<Anonymize<Iblau1qa7u7fet>>;
        },
        {
            /**
             *A error in the list interface implementation.
             */
            List: PlainDescriptor<BagsListListListError>;
        },
        {
            /**
             * The list of thresholds separating the various bags.
             *
             * Ids are separated into unsorted bags according to their score. This specifies the
             * thresholds separating the bags. An id's bag is the largest bag for which the id's score
             * is less than or equal to its upper threshold.
             *
             * When ids are iterated, higher bags are iterated completely before lower bags. This means
             * that iteration is _semi-sorted_: ids of higher score tend to come before ids of lower
             * score, but peer ids within a particular bag are sorted in insertion order.
             *
             * # Expressing the constant
             *
             * This constant must be sorted in strictly increasing order. Duplicate items are not
             * permitted.
             *
             * There is an implied upper limit of `Score::MAX`; that value does not need to be
             * specified within the bag. For any two threshold lists, if one ends with
             * `Score::MAX`, the other one does not, and they are otherwise equal, the two
             * lists will behave identically.
             *
             * # Calculation
             *
             * It is recommended to generate the set of thresholds in a geometric series, such that
             * there exists some constant ratio such that `threshold[k + 1] == (threshold[k] *
             * constant_ratio).max(threshold[k] + 1)` for all `k`.
             *
             * The helpers in the `/utils/frame/generate-bags` module can simplify this calculation.
             *
             * # Examples
             *
             * - If `BagThresholds::get().is_empty()`, then all ids are put into the same bag, and
             *   iteration is strictly in insertion order.
             * - If `BagThresholds::get().len() == 64`, and the thresholds are determined according to
             *   the procedure given above, then the constant ratio is equal to 2.
             * - If `BagThresholds::get().len() == 200`, and the thresholds are determined according to
             *   the procedure given above, then the constant ratio is approximately equal to 1.248.
             * - If the threshold list begins `[1, 2, 3, ...]`, then an id with score 0 or 1 will fall
             *   into bag 0, an id with score 2 will fall into bag 1, etc.
             *
             * # Migration
             *
             * In the event that this list ever changes, a copy of the old bags list must be retained.
             * With that `List::migrate` can be called, which will perform the appropriate migration.
             */
            BagThresholds: PlainDescriptor<Anonymize<Iafqnechp3omqg>>;
        }
    ];
    NominationPools: [
        {
            /**
             * The sum of funds across all pools.
             *
             * This might be lower but never higher than the sum of `total_balance` of all [`PoolMembers`]
             * because calling `pool_withdraw_unbonded` might decrease the total stake of the pool's
             * `bonded_account` without adjusting the pallet-internal `UnbondingPool`'s.
             */
            TotalValueLocked: StorageDescriptor<[], bigint, false>;
            /**
             * Minimum amount to bond to join a pool.
             */
            MinJoinBond: StorageDescriptor<[], bigint, false>;
            /**
             * Minimum bond required to create a pool.
             *
             * This is the amount that the depositor must put as their initial stake in the pool, as an
             * indication of "skin in the game".
             *
             * This is the value that will always exist in the staking ledger of the pool bonded account
             * while all other accounts leave.
             */
            MinCreateBond: StorageDescriptor<[], bigint, false>;
            /**
             * Maximum number of nomination pools that can exist. If `None`, then an unbounded number of
             * pools can exist.
             */
            MaxPools: StorageDescriptor<[], number, true>;
            /**
             * Maximum number of members that can exist in the system. If `None`, then the count
             * members are not bound on a system wide basis.
             */
            MaxPoolMembers: StorageDescriptor<[], number, true>;
            /**
             * Maximum number of members that may belong to pool. If `None`, then the count of
             * members is not bound on a per pool basis.
             */
            MaxPoolMembersPerPool: StorageDescriptor<[], number, true>;
            /**
             * The maximum commission that can be charged by a pool. Used on commission payouts to bound
             * pool commissions that are > `GlobalMaxCommission`, necessary if a future
             * `GlobalMaxCommission` is lower than some current pool commissions.
             */
            GlobalMaxCommission: StorageDescriptor<[], number, true>;
            /**
             * Active members.
             *
             * TWOX-NOTE: SAFE since `AccountId` is a secure hash.
             */
            PoolMembers: StorageDescriptor<[Key: SS58String], Anonymize<Idphjddn2h69vc>, true>;
            /**
             *Counter for the related counted storage map
             */
            CounterForPoolMembers: StorageDescriptor<[], number, false>;
            /**
             * Storage for bonded pools.
             */
            BondedPools: StorageDescriptor<[Key: number], Anonymize<I13ttsmlfr8g52>, true>;
            /**
             *Counter for the related counted storage map
             */
            CounterForBondedPools: StorageDescriptor<[], number, false>;
            /**
             * Reward pools. This is where there rewards for each pool accumulate. When a members payout is
             * claimed, the balance comes out fo the reward pool. Keyed by the bonded pools account.
             */
            RewardPools: StorageDescriptor<[Key: number], Anonymize<If6qa32dj75gu1>, true>;
            /**
             *Counter for the related counted storage map
             */
            CounterForRewardPools: StorageDescriptor<[], number, false>;
            /**
             * Groups of unbonding pools. Each group of unbonding pools belongs to a
             * bonded pool, hence the name sub-pools. Keyed by the bonded pools account.
             */
            SubPoolsStorage: StorageDescriptor<[Key: number], Anonymize<I7oo2mprv1qd1s>, true>;
            /**
             *Counter for the related counted storage map
             */
            CounterForSubPoolsStorage: StorageDescriptor<[], number, false>;
            /**
             * Metadata for the pool.
             */
            Metadata: StorageDescriptor<[Key: number], Binary, false>;
            /**
             *Counter for the related counted storage map
             */
            CounterForMetadata: StorageDescriptor<[], number, false>;
            /**
             * Ever increasing number of all pools created so far.
             */
            LastPoolId: StorageDescriptor<[], number, false>;
            /**
             * A reverse lookup from the pool's account id to its id.
             *
             * This is only used for slashing. In all other instances, the pool id is used, and the
             * accounts are deterministically derived from it.
             */
            ReversePoolIdLookup: StorageDescriptor<[Key: SS58String], number, true>;
            /**
             *Counter for the related counted storage map
             */
            CounterForReversePoolIdLookup: StorageDescriptor<[], number, false>;
            /**
             * Map from a pool member account to their opted claim permission.
             */
            ClaimPermissions: StorageDescriptor<[Key: SS58String], NominationPoolsClaimPermission, false>;
        },
        {
            /**
             *See [`Pallet::join`].
             */
            join: TxDescriptor<Anonymize<Ieg1oc56mamrl5>>;
            /**
             *See [`Pallet::bond_extra`].
             */
            bond_extra: TxDescriptor<Anonymize<Ifi2b6p41bfb97>>;
            /**
             *See [`Pallet::claim_payout`].
             */
            claim_payout: TxDescriptor<undefined>;
            /**
             *See [`Pallet::unbond`].
             */
            unbond: TxDescriptor<Anonymize<Itveli0chegtk>>;
            /**
             *See [`Pallet::pool_withdraw_unbonded`].
             */
            pool_withdraw_unbonded: TxDescriptor<Anonymize<I36uoc8t9liv80>>;
            /**
             *See [`Pallet::withdraw_unbonded`].
             */
            withdraw_unbonded: TxDescriptor<Anonymize<I1u21ookp1djj3>>;
            /**
             *See [`Pallet::create`].
             */
            create: TxDescriptor<Anonymize<If5k9orpn9fi43>>;
            /**
             *See [`Pallet::create_with_pool_id`].
             */
            create_with_pool_id: TxDescriptor<Anonymize<I1hlpf8ergrg8k>>;
            /**
             *See [`Pallet::nominate`].
             */
            nominate: TxDescriptor<Anonymize<I47a2tsd2o2b1c>>;
            /**
             *See [`Pallet::set_state`].
             */
            set_state: TxDescriptor<Anonymize<Ibat0jog71khv5>>;
            /**
             *See [`Pallet::set_metadata`].
             */
            set_metadata: TxDescriptor<Anonymize<I4ihj26hl75e5p>>;
            /**
             *See [`Pallet::set_configs`].
             */
            set_configs: TxDescriptor<Anonymize<I2rqmn40aam5hg>>;
            /**
             *See [`Pallet::update_roles`].
             */
            update_roles: TxDescriptor<Anonymize<I3cvu4kn8n81uv>>;
            /**
             *See [`Pallet::chill`].
             */
            chill: TxDescriptor<Anonymize<I931cottvong90>>;
            /**
             *See [`Pallet::bond_extra_other`].
             */
            bond_extra_other: TxDescriptor<Anonymize<I6l7t90ftdbsr6>>;
            /**
             *See [`Pallet::set_claim_permission`].
             */
            set_claim_permission: TxDescriptor<Anonymize<Icbgkt7i4ps8kc>>;
            /**
             *See [`Pallet::claim_payout_other`].
             */
            claim_payout_other: TxDescriptor<Anonymize<I40s11r8nagn2g>>;
            /**
             *See [`Pallet::set_commission`].
             */
            set_commission: TxDescriptor<Anonymize<I6bjj87fr5g9nl>>;
            /**
             *See [`Pallet::set_commission_max`].
             */
            set_commission_max: TxDescriptor<Anonymize<I8cbluptqo8kbp>>;
            /**
             *See [`Pallet::set_commission_change_rate`].
             */
            set_commission_change_rate: TxDescriptor<Anonymize<I81cc4plffa1dm>>;
            /**
             *See [`Pallet::claim_commission`].
             */
            claim_commission: TxDescriptor<Anonymize<I931cottvong90>>;
            /**
             *See [`Pallet::adjust_pool_deposit`].
             */
            adjust_pool_deposit: TxDescriptor<Anonymize<I931cottvong90>>;
        },
        {
            /**
             *A pool has been created.
             */
            Created: PlainDescriptor<Anonymize<I1ti389kf8t6oi>>;
            /**
             *A member has became bonded in a pool.
             */
            Bonded: PlainDescriptor<Anonymize<If4nnre373amul>>;
            /**
             *A payout has been made to a member.
             */
            PaidOut: PlainDescriptor<Anonymize<I55kbor0ocqk6h>>;
            /**
             *A member has unbonded from their pool.
             *
             *- `balance` is the corresponding balance of the number of points that has been
             *  requested to be unbonded (the argument of the `unbond` transaction) from the bonded
             *  pool.
             *- `points` is the number of points that are issued as a result of `balance` being
             *dissolved into the corresponding unbonding pool.
             *- `era` is the era in which the balance will be unbonded.
             *In the absence of slashing, these values will match. In the presence of slashing, the
             *number of points that are issued in the unbonding pool will be less than the amount
             *requested to be unbonded.
             */
            Unbonded: PlainDescriptor<Anonymize<Idsj9cg7j96kpc>>;
            /**
             *A member has withdrawn from their pool.
             *
             *The given number of `points` have been dissolved in return of `balance`.
             *
             *Similar to `Unbonded` event, in the absence of slashing, the ratio of point to balance
             *will be 1.
             */
            Withdrawn: PlainDescriptor<Anonymize<Ido4u9drncfaml>>;
            /**
             *A pool has been destroyed.
             */
            Destroyed: PlainDescriptor<Anonymize<I931cottvong90>>;
            /**
             *The state of a pool has changed
             */
            StateChanged: PlainDescriptor<Anonymize<I2inhcpqb4h0bg>>;
            /**
             *A member has been removed from a pool.
             *
             *The removal can be voluntary (withdrawn all unbonded funds) or involuntary (kicked).
             */
            MemberRemoved: PlainDescriptor<Anonymize<I7vqogd77mmdlm>>;
            /**
             *The roles of a pool have been updated to the given new roles. Note that the depositor
             *can never change.
             */
            RolesUpdated: PlainDescriptor<Anonymize<I6mik29s5073td>>;
            /**
             *The active balance of pool `pool_id` has been slashed to `balance`.
             */
            PoolSlashed: PlainDescriptor<Anonymize<I2m0sqmb75cnpb>>;
            /**
             *The unbond pool at `era` of pool `pool_id` has been slashed to `balance`.
             */
            UnbondingPoolSlashed: PlainDescriptor<Anonymize<I49agc5b62mehu>>;
            /**
             *A pool's commission setting has been changed.
             */
            PoolCommissionUpdated: PlainDescriptor<Anonymize<Iatq9jda4hq6pg>>;
            /**
             *A pool's maximum commission setting has been changed.
             */
            PoolMaxCommissionUpdated: PlainDescriptor<Anonymize<I8cbluptqo8kbp>>;
            /**
             *A pool's commission `change_rate` has been changed.
             */
            PoolCommissionChangeRateUpdated: PlainDescriptor<Anonymize<I81cc4plffa1dm>>;
            /**
             *Pool commission has been claimed.
             */
            PoolCommissionClaimed: PlainDescriptor<Anonymize<I2g87evcjlgmqi>>;
            /**
             *Topped up deficit in frozen ED of the reward pool.
             */
            MinBalanceDeficitAdjusted: PlainDescriptor<Anonymize<Ieg1oc56mamrl5>>;
            /**
             *Claimed excess frozen ED of af the reward pool.
             */
            MinBalanceExcessAdjusted: PlainDescriptor<Anonymize<Ieg1oc56mamrl5>>;
        },
        {
            /**
             *A (bonded) pool id does not exist.
             */
            PoolNotFound: PlainDescriptor<undefined>;
            /**
             *An account is not a member.
             */
            PoolMemberNotFound: PlainDescriptor<undefined>;
            /**
             *A reward pool does not exist. In all cases this is a system logic error.
             */
            RewardPoolNotFound: PlainDescriptor<undefined>;
            /**
             *A sub pool does not exist.
             */
            SubPoolsNotFound: PlainDescriptor<undefined>;
            /**
             *An account is already delegating in another pool. An account may only belong to one
             *pool at a time.
             */
            AccountBelongsToOtherPool: PlainDescriptor<undefined>;
            /**
             *The member is fully unbonded (and thus cannot access the bonded and reward pool
             *anymore to, for example, collect rewards).
             */
            FullyUnbonding: PlainDescriptor<undefined>;
            /**
             *The member cannot unbond further chunks due to reaching the limit.
             */
            MaxUnbondingLimit: PlainDescriptor<undefined>;
            /**
             *None of the funds can be withdrawn yet because the bonding duration has not passed.
             */
            CannotWithdrawAny: PlainDescriptor<undefined>;
            /**
             *The amount does not meet the minimum bond to either join or create a pool.
             *
             *The depositor can never unbond to a value less than `Pallet::depositor_min_bond`. The
             *caller does not have nominating permissions for the pool. Members can never unbond to a
             *value below `MinJoinBond`.
             */
            MinimumBondNotMet: PlainDescriptor<undefined>;
            /**
             *The transaction could not be executed due to overflow risk for the pool.
             */
            OverflowRisk: PlainDescriptor<undefined>;
            /**
             *A pool must be in [`PoolState::Destroying`] in order for the depositor to unbond or for
             *other members to be permissionlessly unbonded.
             */
            NotDestroying: PlainDescriptor<undefined>;
            /**
             *The caller does not have nominating permissions for the pool.
             */
            NotNominator: PlainDescriptor<undefined>;
            /**
             *Either a) the caller cannot make a valid kick or b) the pool is not destroying.
             */
            NotKickerOrDestroying: PlainDescriptor<undefined>;
            /**
             *The pool is not open to join
             */
            NotOpen: PlainDescriptor<undefined>;
            /**
             *The system is maxed out on pools.
             */
            MaxPools: PlainDescriptor<undefined>;
            /**
             *Too many members in the pool or system.
             */
            MaxPoolMembers: PlainDescriptor<undefined>;
            /**
             *The pools state cannot be changed.
             */
            CanNotChangeState: PlainDescriptor<undefined>;
            /**
             *The caller does not have adequate permissions.
             */
            DoesNotHavePermission: PlainDescriptor<undefined>;
            /**
             *Metadata exceeds [`Config::MaxMetadataLen`]
             */
            MetadataExceedsMaxLen: PlainDescriptor<undefined>;
            /**
             *Some error occurred that should never happen. This should be reported to the
             *maintainers.
             */
            Defensive: PlainDescriptor<NominationPoolsPalletDefensiveError>;
            /**
             *Partial unbonding now allowed permissionlessly.
             */
            PartialUnbondNotAllowedPermissionlessly: PlainDescriptor<undefined>;
            /**
             *The pool's max commission cannot be set higher than the existing value.
             */
            MaxCommissionRestricted: PlainDescriptor<undefined>;
            /**
             *The supplied commission exceeds the max allowed commission.
             */
            CommissionExceedsMaximum: PlainDescriptor<undefined>;
            /**
             *The supplied commission exceeds global maximum commission.
             */
            CommissionExceedsGlobalMaximum: PlainDescriptor<undefined>;
            /**
             *Not enough blocks have surpassed since the last commission update.
             */
            CommissionChangeThrottled: PlainDescriptor<undefined>;
            /**
             *The submitted changes to commission change rate are not allowed.
             */
            CommissionChangeRateNotAllowed: PlainDescriptor<undefined>;
            /**
             *There is no pending commission to claim.
             */
            NoPendingCommission: PlainDescriptor<undefined>;
            /**
             *No commission current has been set.
             */
            NoCommissionCurrentSet: PlainDescriptor<undefined>;
            /**
             *Pool id currently in use.
             */
            PoolIdInUse: PlainDescriptor<undefined>;
            /**
             *Pool id provided is not correct/usable.
             */
            InvalidPoolId: PlainDescriptor<undefined>;
            /**
             *Bonding extra is restricted to the exact pending reward amount.
             */
            BondExtraRestricted: PlainDescriptor<undefined>;
            /**
             *No imbalance in the ED deposit for the pool.
             */
            NothingToAdjust: PlainDescriptor<undefined>;
        },
        {
            /**
             * The nomination pool's pallet id.
             */
            PalletId: PlainDescriptor<Binary>;
            /**
             * The maximum pool points-to-balance ratio that an `open` pool can have.
             *
             * This is important in the event slashing takes place and the pool's points-to-balance
             * ratio becomes disproportional.
             *
             * Moreover, this relates to the `RewardCounter` type as well, as the arithmetic operations
             * are a function of number of points, and by setting this value to e.g. 10, you ensure
             * that the total number of points in the system are at most 10 times the total_issuance of
             * the chain, in the absolute worse case.
             *
             * For a value of 10, the threshold would be a pool points-to-balance ratio of 10:1.
             * Such a scenario would also be the equivalent of the pool being 90% slashed.
             */
            MaxPointsToBalance: PlainDescriptor<number>;
        }
    ];
    FastUnstake: [
        {
            /**
             * The current "head of the queue" being unstaked.
             *
             * The head in itself can be a batch of up to [`Config::BatchSize`] stakers.
             */
            Head: StorageDescriptor<[], Anonymize<I2eh80qovrl7h2>, true>;
            /**
             * The map of all accounts wishing to be unstaked.
             *
             * Keeps track of `AccountId` wishing to unstake and it's corresponding deposit.
             */
            Queue: StorageDescriptor<[Key: SS58String], bigint, true>;
            /**
             *Counter for the related counted storage map
             */
            CounterForQueue: StorageDescriptor<[], number, false>;
            /**
             * Number of eras to check per block.
             *
             * If set to 0, this pallet does absolutely nothing. Cannot be set to more than
             * [`Config::MaxErasToCheckPerBlock`].
             *
             * Based on the amount of weight available at [`Pallet::on_idle`], up to this many eras are
             * checked. The checking is represented by updating [`UnstakeRequest::checked`], which is
             * stored in [`Head`].
             */
            ErasToCheckPerBlock: StorageDescriptor<[], number, false>;
        },
        {
            /**
             *See [`Pallet::register_fast_unstake`].
             */
            register_fast_unstake: TxDescriptor<undefined>;
            /**
             *See [`Pallet::deregister`].
             */
            deregister: TxDescriptor<undefined>;
            /**
             *See [`Pallet::control`].
             */
            control: TxDescriptor<Anonymize<I9j0ul7nh7b8jv>>;
        },
        {
            /**
             *A staker was unstaked.
             */
            Unstaked: PlainDescriptor<Anonymize<Iag2vtju06tj0k>>;
            /**
             *A staker was slashed for requesting fast-unstake whilst being exposed.
             */
            Slashed: PlainDescriptor<Anonymize<Ifk8eme5o7mukf>>;
            /**
             *A batch was partially checked for the given eras, but the process did not finish.
             */
            BatchChecked: PlainDescriptor<Anonymize<Ic0he9tlf9ll0u>>;
            /**
             *A batch of a given size was terminated.
             *
             *This is always follows by a number of `Unstaked` or `Slashed` events, marking the end
             *of the batch. A new batch will be created upon next block.
             */
            BatchFinished: PlainDescriptor<Anonymize<I54umskavgc9du>>;
            /**
             *An internal error happened. Operations will be paused now.
             */
            InternalError: PlainDescriptor<undefined>;
        },
        {
            /**
             *The provided Controller account was not found.
             *
             *This means that the given account is not bonded.
             */
            NotController: PlainDescriptor<undefined>;
            /**
             *The bonded account has already been queued.
             */
            AlreadyQueued: PlainDescriptor<undefined>;
            /**
             *The bonded account has active unlocking chunks.
             */
            NotFullyBonded: PlainDescriptor<undefined>;
            /**
             *The provided un-staker is not in the `Queue`.
             */
            NotQueued: PlainDescriptor<undefined>;
            /**
             *The provided un-staker is already in Head, and cannot deregister.
             */
            AlreadyHead: PlainDescriptor<undefined>;
            /**
             *The call is not allowed at this point because the pallet is not active.
             */
            CallNotAllowed: PlainDescriptor<undefined>;
        },
        {
            /**
             * Deposit to take for unstaking, to make sure we're able to slash the it in order to cover
             * the costs of resources on unsuccessful unstake.
             */
            Deposit: PlainDescriptor<bigint>;
        }
    ];
    ParachainsOrigin: [{}, {}, {}, {}, {}];
    Configuration: [
        {
            /**
             * The active configuration for the current session.
             */
            ActiveConfig: StorageDescriptor<[], Anonymize<Ia2hpj72knb2q9>, false>;
            /**
             * Pending configuration changes.
             *
             * This is a list of configuration changes, each with a session index at which it should
             * be applied.
             *
             * The list is sorted ascending by session index. Also, this list can only contain at most
             * 2 items: for the next session and for the `scheduled_session`.
             */
            PendingConfigs: StorageDescriptor<[], Anonymize<Ies9ffs3ho1o06>, false>;
            /**
             * If this is set, then the configuration setters will bypass the consistency checks. This
             * is meant to be used only as the last resort.
             */
            BypassConsistencyCheck: StorageDescriptor<[], boolean, false>;
        },
        {
            /**
             *See [`Pallet::set_validation_upgrade_cooldown`].
             */
            set_validation_upgrade_cooldown: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_validation_upgrade_delay`].
             */
            set_validation_upgrade_delay: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_code_retention_period`].
             */
            set_code_retention_period: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_max_code_size`].
             */
            set_max_code_size: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_max_pov_size`].
             */
            set_max_pov_size: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_max_head_data_size`].
             */
            set_max_head_data_size: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_on_demand_cores`].
             */
            set_on_demand_cores: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_on_demand_retries`].
             */
            set_on_demand_retries: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_group_rotation_frequency`].
             */
            set_group_rotation_frequency: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_paras_availability_period`].
             */
            set_paras_availability_period: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_scheduling_lookahead`].
             */
            set_scheduling_lookahead: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_max_validators_per_core`].
             */
            set_max_validators_per_core: TxDescriptor<Anonymize<Id581arok0b1nj>>;
            /**
             *See [`Pallet::set_max_validators`].
             */
            set_max_validators: TxDescriptor<Anonymize<Id581arok0b1nj>>;
            /**
             *See [`Pallet::set_dispute_period`].
             */
            set_dispute_period: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_dispute_post_conclusion_acceptance_period`].
             */
            set_dispute_post_conclusion_acceptance_period: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_no_show_slots`].
             */
            set_no_show_slots: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_n_delay_tranches`].
             */
            set_n_delay_tranches: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_zeroth_delay_tranche_width`].
             */
            set_zeroth_delay_tranche_width: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_needed_approvals`].
             */
            set_needed_approvals: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_relay_vrf_modulo_samples`].
             */
            set_relay_vrf_modulo_samples: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_max_upward_queue_count`].
             */
            set_max_upward_queue_count: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_max_upward_queue_size`].
             */
            set_max_upward_queue_size: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_max_downward_message_size`].
             */
            set_max_downward_message_size: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_max_upward_message_size`].
             */
            set_max_upward_message_size: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_max_upward_message_num_per_candidate`].
             */
            set_max_upward_message_num_per_candidate: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_hrmp_open_request_ttl`].
             */
            set_hrmp_open_request_ttl: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_hrmp_sender_deposit`].
             */
            set_hrmp_sender_deposit: TxDescriptor<Anonymize<I9jsikd1ghmc7l>>;
            /**
             *See [`Pallet::set_hrmp_recipient_deposit`].
             */
            set_hrmp_recipient_deposit: TxDescriptor<Anonymize<I9jsikd1ghmc7l>>;
            /**
             *See [`Pallet::set_hrmp_channel_max_capacity`].
             */
            set_hrmp_channel_max_capacity: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_hrmp_channel_max_total_size`].
             */
            set_hrmp_channel_max_total_size: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_hrmp_max_parachain_inbound_channels`].
             */
            set_hrmp_max_parachain_inbound_channels: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_hrmp_channel_max_message_size`].
             */
            set_hrmp_channel_max_message_size: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_hrmp_max_parachain_outbound_channels`].
             */
            set_hrmp_max_parachain_outbound_channels: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_hrmp_max_message_num_per_candidate`].
             */
            set_hrmp_max_message_num_per_candidate: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_pvf_voting_ttl`].
             */
            set_pvf_voting_ttl: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_minimum_validation_upgrade_delay`].
             */
            set_minimum_validation_upgrade_delay: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_bypass_consistency_check`].
             */
            set_bypass_consistency_check: TxDescriptor<Anonymize<I2f6mha3v4ooda>>;
            /**
             *See [`Pallet::set_async_backing_params`].
             */
            set_async_backing_params: TxDescriptor<Anonymize<Iasqjdhasi408s>>;
            /**
             *See [`Pallet::set_executor_params`].
             */
            set_executor_params: TxDescriptor<Anonymize<Iehb5cb6rp4k2p>>;
            /**
             *See [`Pallet::set_on_demand_base_fee`].
             */
            set_on_demand_base_fee: TxDescriptor<Anonymize<I9jsikd1ghmc7l>>;
            /**
             *See [`Pallet::set_on_demand_fee_variability`].
             */
            set_on_demand_fee_variability: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_on_demand_queue_max_size`].
             */
            set_on_demand_queue_max_size: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_on_demand_target_queue_utilization`].
             */
            set_on_demand_target_queue_utilization: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_on_demand_ttl`].
             */
            set_on_demand_ttl: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
            /**
             *See [`Pallet::set_minimum_backing_votes`].
             */
            set_minimum_backing_votes: TxDescriptor<Anonymize<I3vh014cqgmrfd>>;
        },
        {},
        {
            /**
             *The new value for a configuration parameter is invalid.
             */
            InvalidNewValue: PlainDescriptor<undefined>;
        },
        {}
    ];
    ParasShared: [
        {
            /**
             * The current session index.
             */
            CurrentSessionIndex: StorageDescriptor<[], number, false>;
            /**
             * All the validators actively participating in parachain consensus.
             * Indices are into the broader validator set.
             */
            ActiveValidatorIndices: StorageDescriptor<[], Anonymize<Icgljjb6j82uhn>, false>;
            /**
             * The parachain attestation keys of the validators actively participating in parachain
             * consensus. This should be the same length as `ActiveValidatorIndices`.
             */
            ActiveValidatorKeys: StorageDescriptor<[], Anonymize<Idhnf6rtqoslea>, false>;
            /**
             * All allowed relay-parents.
             */
            AllowedRelayParents: StorageDescriptor<[], Anonymize<I663ddds93n8hc>, false>;
        },
        {},
        {},
        {},
        {}
    ];
    ParaInclusion: [
        {
            /**
             * The latest bitfield for each validator, referred to by their index in the validator set.
             */
            AvailabilityBitfields: StorageDescriptor<[Key: number], Anonymize<I78e99376i3249>, true>;
            /**
             * Candidates pending availability by `ParaId`.
             */
            PendingAvailability: StorageDescriptor<[Key: number], Anonymize<Ic4ms979ng98e4>, true>;
            /**
             * The commitments of candidates pending availability, by `ParaId`.
             */
            PendingAvailabilityCommitments: StorageDescriptor<[Key: number], Anonymize<Ic1d4u2opv3fst>, true>;
        },
        {},
        {
            /**
             *A candidate was backed. `[candidate, head_data]`
             */
            CandidateBacked: PlainDescriptor<Anonymize<Ieno5vn1m65ng2>>;
            /**
             *A candidate was included. `[candidate, head_data]`
             */
            CandidateIncluded: PlainDescriptor<Anonymize<Ieno5vn1m65ng2>>;
            /**
             *A candidate timed out. `[candidate, head_data]`
             */
            CandidateTimedOut: PlainDescriptor<Anonymize<Ievbvtucck5gnq>>;
            /**
             *Some upward messages have been received and will be processed.
             */
            UpwardMessagesReceived: PlainDescriptor<Anonymize<Ic8i89mfkmn3n7>>;
        },
        {
            /**
             *Validator indices are out of order or contains duplicates.
             */
            UnsortedOrDuplicateValidatorIndices: PlainDescriptor<undefined>;
            /**
             *Dispute statement sets are out of order or contain duplicates.
             */
            UnsortedOrDuplicateDisputeStatementSet: PlainDescriptor<undefined>;
            /**
             *Backed candidates are out of order (core index) or contain duplicates.
             */
            UnsortedOrDuplicateBackedCandidates: PlainDescriptor<undefined>;
            /**
             *A different relay parent was provided compared to the on-chain stored one.
             */
            UnexpectedRelayParent: PlainDescriptor<undefined>;
            /**
             *Availability bitfield has unexpected size.
             */
            WrongBitfieldSize: PlainDescriptor<undefined>;
            /**
             *Bitfield consists of zeros only.
             */
            BitfieldAllZeros: PlainDescriptor<undefined>;
            /**
             *Multiple bitfields submitted by same validator or validators out of order by index.
             */
            BitfieldDuplicateOrUnordered: PlainDescriptor<undefined>;
            /**
             *Validator index out of bounds.
             */
            ValidatorIndexOutOfBounds: PlainDescriptor<undefined>;
            /**
             *Invalid signature
             */
            InvalidBitfieldSignature: PlainDescriptor<undefined>;
            /**
             *Candidate submitted but para not scheduled.
             */
            UnscheduledCandidate: PlainDescriptor<undefined>;
            /**
             *Candidate scheduled despite pending candidate already existing for the para.
             */
            CandidateScheduledBeforeParaFree: PlainDescriptor<undefined>;
            /**
             *Scheduled cores out of order.
             */
            ScheduledOutOfOrder: PlainDescriptor<undefined>;
            /**
             *Head data exceeds the configured maximum.
             */
            HeadDataTooLarge: PlainDescriptor<undefined>;
            /**
             *Code upgrade prematurely.
             */
            PrematureCodeUpgrade: PlainDescriptor<undefined>;
            /**
             *Output code is too large
             */
            NewCodeTooLarge: PlainDescriptor<undefined>;
            /**
             *The candidate's relay-parent was not allowed. Either it was
             *not recent enough or it didn't advance based on the last parachain block.
             */
            DisallowedRelayParent: PlainDescriptor<undefined>;
            /**
             *Failed to compute group index for the core: either it's out of bounds
             *or the relay parent doesn't belong to the current session.
             */
            InvalidAssignment: PlainDescriptor<undefined>;
            /**
             *Invalid group index in core assignment.
             */
            InvalidGroupIndex: PlainDescriptor<undefined>;
            /**
             *Insufficient (non-majority) backing.
             */
            InsufficientBacking: PlainDescriptor<undefined>;
            /**
             *Invalid (bad signature, unknown validator, etc.) backing.
             */
            InvalidBacking: PlainDescriptor<undefined>;
            /**
             *Collator did not sign PoV.
             */
            NotCollatorSigned: PlainDescriptor<undefined>;
            /**
             *The validation data hash does not match expected.
             */
            ValidationDataHashMismatch: PlainDescriptor<undefined>;
            /**
             *The downward message queue is not processed correctly.
             */
            IncorrectDownwardMessageHandling: PlainDescriptor<undefined>;
            /**
             *At least one upward message sent does not pass the acceptance criteria.
             */
            InvalidUpwardMessages: PlainDescriptor<undefined>;
            /**
             *The candidate didn't follow the rules of HRMP watermark advancement.
             */
            HrmpWatermarkMishandling: PlainDescriptor<undefined>;
            /**
             *The HRMP messages sent by the candidate is not valid.
             */
            InvalidOutboundHrmp: PlainDescriptor<undefined>;
            /**
             *The validation code hash of the candidate is not valid.
             */
            InvalidValidationCodeHash: PlainDescriptor<undefined>;
            /**
             *The `para_head` hash in the candidate descriptor doesn't match the hash of the actual
             *para head in the commitments.
             */
            ParaHeadMismatch: PlainDescriptor<undefined>;
            /**
             *A bitfield that references a freed core,
             *either intentionally or as part of a concluded
             *invalid dispute.
             */
            BitfieldReferencesFreedCore: PlainDescriptor<undefined>;
        },
        {}
    ];
    ParaInherent: [
        {
            /**
             * Whether the paras inherent was included within this block.
             *
             * The `Option<()>` is effectively a `bool`, but it never hits storage in the `None` variant
             * due to the guarantees of FRAME's storage APIs.
             *
             * If this is `None` at the end of the block, we panic and render the block invalid.
             */
            Included: StorageDescriptor<[], undefined, true>;
            /**
             * Scraped on chain data for extracting resolved disputes as well as backing votes.
             */
            OnChainVotes: StorageDescriptor<[], Anonymize<I3qttgoifdk5v6>, true>;
        },
        {
            /**
             *See [`Pallet::enter`].
             */
            enter: TxDescriptor<Anonymize<I6uj8ujct0o4v7>>;
        },
        {},
        {
            /**
             *Inclusion inherent called more than once per block.
             */
            TooManyInclusionInherents: PlainDescriptor<undefined>;
            /**
             *The hash of the submitted parent header doesn't correspond to the saved block hash of
             *the parent.
             */
            InvalidParentHeader: PlainDescriptor<undefined>;
            /**
             *Disputed candidate that was concluded invalid.
             */
            CandidateConcludedInvalid: PlainDescriptor<undefined>;
            /**
             *The data given to the inherent will result in an overweight block.
             */
            InherentOverweight: PlainDescriptor<undefined>;
            /**
             *The ordering of dispute statements was invalid.
             */
            DisputeStatementsUnsortedOrDuplicates: PlainDescriptor<undefined>;
            /**
             *A dispute statement was invalid.
             */
            DisputeInvalid: PlainDescriptor<undefined>;
        },
        {}
    ];
    ParaScheduler: [
        {
            /**
             * All the validator groups. One for each core. Indices are into `ActiveValidators` - not the
             * broader set of Polkadot validators, but instead just the subset used for parachains during
             * this session.
             *
             * Bound: The number of cores is the sum of the numbers of parachains and parathread
             * multiplexers. Reasonably, 100-1000. The dominant factor is the number of validators: safe
             * upper bound at 10k.
             */
            ValidatorGroups: StorageDescriptor<[], Anonymize<Iarlj3qd8u1v13>, false>;
            /**
             * One entry for each availability core. Entries are `None` if the core is not currently
             * occupied. Can be temporarily `Some` if scheduled but not occupied.
             * The i'th parachain belongs to the i'th core, with the remaining cores all being
             * parathread-multiplexers.
             *
             * Bounded by the maximum of either of these two values:
             *   * The number of parachains and parathread multiplexers
             *   * The number of validators divided by `configuration.max_validators_per_core`.
             */
            AvailabilityCores: StorageDescriptor<[], Anonymize<In9ekmba4m5ft>, false>;
            /**
             * The block number where the session start occurred. Used to track how many group rotations
             * have occurred.
             *
             * Note that in the context of parachains modules the session change is signaled during
             * the block and enacted at the end of the block (at the finalization stage, to be exact).
             * Thus for all intents and purposes the effect of the session change is observed at the
             * block following the session change, block number of which we save in this storage value.
             */
            SessionStartBlock: StorageDescriptor<[], number, false>;
            /**
             * One entry for each availability core. The `VecDeque` represents the assignments to be
             * scheduled on that core. `None` is used to signal to not schedule the next para of the core
             * as there is one currently being scheduled. Not using `None` here would overwrite the
             * `CoreState` in the runtime API. The value contained here will not be valid after the end of
             * a block. Runtime APIs should be used to determine scheduled cores/ for the upcoming block.
             */
            ClaimQueue: StorageDescriptor<[], Anonymize<Ievsccbpmuhatk>, false>;
        },
        {},
        {},
        {},
        {}
    ];
    Paras: [
        {
            /**
             * All currently active PVF pre-checking votes.
             *
             * Invariant:
             * - There are no PVF pre-checking votes that exists in list but not in the set and vice versa.
             */
            PvfActiveVoteMap: StorageDescriptor<[Key: Binary], Anonymize<Iaja1oeag5u4b3>, true>;
            /**
             * The list of all currently active PVF votes. Auxiliary to `PvfActiveVoteMap`.
             */
            PvfActiveVoteList: StorageDescriptor<[], Anonymize<Idhnf6rtqoslea>, false>;
            /**
             * All lease holding parachains. Ordered ascending by `ParaId`. On demand parachains are not
             * included.
             *
             * Consider using the [`ParachainsCache`] type of modifying.
             */
            Parachains: StorageDescriptor<[], Anonymize<Icgljjb6j82uhn>, false>;
            /**
             * The current lifecycle of a all known Para IDs.
             */
            ParaLifecycles: StorageDescriptor<[Key: number], ParachainsParasParaLifecycle, true>;
            /**
             * The head-data of every registered para.
             */
            Heads: StorageDescriptor<[Key: number], Binary, true>;
            /**
             * The context (relay-chain block number) of the most recent parachain head.
             */
            MostRecentContext: StorageDescriptor<[Key: number], number, true>;
            /**
             * The validation code hash of every live para.
             *
             * Corresponding code can be retrieved with [`CodeByHash`].
             */
            CurrentCodeHash: StorageDescriptor<[Key: number], Binary, true>;
            /**
             * Actual past code hash, indicated by the para id as well as the block number at which it
             * became outdated.
             *
             * Corresponding code can be retrieved with [`CodeByHash`].
             */
            PastCodeHash: StorageDescriptor<[Key: Anonymize<I5g2vv0ckl2m8b>], Binary, true>;
            /**
             * Past code of parachains. The parachains themselves may not be registered anymore,
             * but we also keep their code on-chain for the same amount of time as outdated code
             * to keep it available for approval checkers.
             */
            PastCodeMeta: StorageDescriptor<[Key: number], Anonymize<I79cs1p3m59mo7>, false>;
            /**
             * Which paras have past code that needs pruning and the relay-chain block at which the code
             * was replaced. Note that this is the actual height of the included block, not the expected
             * height at which the code upgrade would be applied, although they may be equal.
             * This is to ensure the entire acceptance period is covered, not an offset acceptance period
             * starting from the time at which the parachain perceives a code upgrade as having occurred.
             * Multiple entries for a single para are permitted. Ordered ascending by block number.
             */
            PastCodePruning: StorageDescriptor<[], Anonymize<Iep4uo61810hfs>, false>;
            /**
             * The block number at which the planned code change is expected for a para.
             * The change will be applied after the first parablock for this ID included which executes
             * in the context of a relay chain block with a number >= `expected_at`.
             */
            FutureCodeUpgrades: StorageDescriptor<[Key: number], number, true>;
            /**
             * The actual future code hash of a para.
             *
             * Corresponding code can be retrieved with [`CodeByHash`].
             */
            FutureCodeHash: StorageDescriptor<[Key: number], Binary, true>;
            /**
             * This is used by the relay-chain to communicate to a parachain a go-ahead with in the upgrade
             * procedure.
             *
             * This value is absent when there are no upgrades scheduled or during the time the relay chain
             * performs the checks. It is set at the first relay-chain block when the corresponding
             * parachain can switch its upgrade function. As soon as the parachain's block is included, the
             * value gets reset to `None`.
             *
             * NOTE that this field is used by parachains via merkle storage proofs, therefore changing
             * the format will require migration of parachains.
             */
            UpgradeGoAheadSignal: StorageDescriptor<[Key: number], PolkadotPrimitivesV5UpgradeGoAhead, true>;
            /**
             * This is used by the relay-chain to communicate that there are restrictions for performing
             * an upgrade for this parachain.
             *
             * This may be a because the parachain waits for the upgrade cooldown to expire. Another
             * potential use case is when we want to perform some maintenance (such as storage migration)
             * we could restrict upgrades to make the process simpler.
             *
             * NOTE that this field is used by parachains via merkle storage proofs, therefore changing
             * the format will require migration of parachains.
             */
            UpgradeRestrictionSignal: StorageDescriptor<[Key: number], PolkadotPrimitivesV5UpgradeRestriction, true>;
            /**
             * The list of parachains that are awaiting for their upgrade restriction to cooldown.
             *
             * Ordered ascending by block number.
             */
            UpgradeCooldowns: StorageDescriptor<[], Anonymize<Iep4uo61810hfs>, false>;
            /**
             * The list of upcoming code upgrades. Each item is a pair of which para performs a code
             * upgrade and at which relay-chain block it is expected at.
             *
             * Ordered ascending by block number.
             */
            UpcomingUpgrades: StorageDescriptor<[], Anonymize<Iep4uo61810hfs>, false>;
            /**
             * The actions to perform during the start of a specific session index.
             */
            ActionsQueue: StorageDescriptor<[Key: number], Anonymize<Icgljjb6j82uhn>, false>;
            /**
             * Upcoming paras instantiation arguments.
             *
             * NOTE that after PVF pre-checking is enabled the para genesis arg will have it's code set
             * to empty. Instead, the code will be saved into the storage right away via `CodeByHash`.
             */
            UpcomingParasGenesis: StorageDescriptor<[Key: number], Anonymize<I2duhnt686rv0q>, true>;
            /**
             * The number of reference on the validation code in [`CodeByHash`] storage.
             */
            CodeByHashRefs: StorageDescriptor<[Key: Binary], number, false>;
            /**
             * Validation code stored by its hash.
             *
             * This storage is consistent with [`FutureCodeHash`], [`CurrentCodeHash`] and
             * [`PastCodeHash`].
             */
            CodeByHash: StorageDescriptor<[Key: Binary], Binary, true>;
        },
        {
            /**
             *See [`Pallet::force_set_current_code`].
             */
            force_set_current_code: TxDescriptor<Anonymize<I1k3urvkqqshbc>>;
            /**
             *See [`Pallet::force_set_current_head`].
             */
            force_set_current_head: TxDescriptor<Anonymize<I2ff0ffsh15vej>>;
            /**
             *See [`Pallet::force_schedule_code_upgrade`].
             */
            force_schedule_code_upgrade: TxDescriptor<Anonymize<I1orfg86bkg123>>;
            /**
             *See [`Pallet::force_note_new_head`].
             */
            force_note_new_head: TxDescriptor<Anonymize<I2ff0ffsh15vej>>;
            /**
             *See [`Pallet::force_queue_action`].
             */
            force_queue_action: TxDescriptor<Anonymize<Iaus4cb3drhu9q>>;
            /**
             *See [`Pallet::add_trusted_validation_code`].
             */
            add_trusted_validation_code: TxDescriptor<Anonymize<Ivnsat10lv9d6>>;
            /**
             *See [`Pallet::poke_unused_validation_code`].
             */
            poke_unused_validation_code: TxDescriptor<Anonymize<Ifqm1da2k7es4d>>;
            /**
             *See [`Pallet::include_pvf_check_statement`].
             */
            include_pvf_check_statement: TxDescriptor<Anonymize<I4aouqiv2fh67c>>;
            /**
             *See [`Pallet::force_set_most_recent_context`].
             */
            force_set_most_recent_context: TxDescriptor<Anonymize<I9tmok5kceg2bg>>;
        },
        {
            /**
             *Current code has been updated for a Para. `para_id`
             */
            CurrentCodeUpdated: PlainDescriptor<number>;
            /**
             *Current head has been updated for a Para. `para_id`
             */
            CurrentHeadUpdated: PlainDescriptor<number>;
            /**
             *A code upgrade has been scheduled for a Para. `para_id`
             */
            CodeUpgradeScheduled: PlainDescriptor<number>;
            /**
             *A new head has been noted for a Para. `para_id`
             */
            NewHeadNoted: PlainDescriptor<number>;
            /**
             *A para has been queued to execute pending actions. `para_id`
             */
            ActionQueued: PlainDescriptor<Anonymize<I5g2vv0ckl2m8b>>;
            /**
             *The given para either initiated or subscribed to a PVF check for the given validation
             *code. `code_hash` `para_id`
             */
            PvfCheckStarted: PlainDescriptor<Anonymize<I64gm4hrq7urum>>;
            /**
             *The given validation code was accepted by the PVF pre-checking vote.
             *`code_hash` `para_id`
             */
            PvfCheckAccepted: PlainDescriptor<Anonymize<I64gm4hrq7urum>>;
            /**
             *The given validation code was rejected by the PVF pre-checking vote.
             *`code_hash` `para_id`
             */
            PvfCheckRejected: PlainDescriptor<Anonymize<I64gm4hrq7urum>>;
        },
        {
            /**
             *Para is not registered in our system.
             */
            NotRegistered: PlainDescriptor<undefined>;
            /**
             *Para cannot be onboarded because it is already tracked by our system.
             */
            CannotOnboard: PlainDescriptor<undefined>;
            /**
             *Para cannot be offboarded at this time.
             */
            CannotOffboard: PlainDescriptor<undefined>;
            /**
             *Para cannot be upgraded to a lease holding parachain.
             */
            CannotUpgrade: PlainDescriptor<undefined>;
            /**
             *Para cannot be downgraded to an on-demand parachain.
             */
            CannotDowngrade: PlainDescriptor<undefined>;
            /**
             *The statement for PVF pre-checking is stale.
             */
            PvfCheckStatementStale: PlainDescriptor<undefined>;
            /**
             *The statement for PVF pre-checking is for a future session.
             */
            PvfCheckStatementFuture: PlainDescriptor<undefined>;
            /**
             *Claimed validator index is out of bounds.
             */
            PvfCheckValidatorIndexOutOfBounds: PlainDescriptor<undefined>;
            /**
             *The signature for the PVF pre-checking is invalid.
             */
            PvfCheckInvalidSignature: PlainDescriptor<undefined>;
            /**
             *The given validator already has cast a vote.
             */
            PvfCheckDoubleVote: PlainDescriptor<undefined>;
            /**
             *The given PVF does not exist at the moment of process a vote.
             */
            PvfCheckSubjectInvalid: PlainDescriptor<undefined>;
            /**
             *Parachain cannot currently schedule a code upgrade.
             */
            CannotUpgradeCode: PlainDescriptor<undefined>;
        },
        {
            /**
            
             */
            UnsignedPriority: PlainDescriptor<bigint>;
        }
    ];
    Initializer: [
        {
            /**
             * Whether the parachains modules have been initialized within this block.
             *
             * Semantically a `bool`, but this guarantees it should never hit the trie,
             * as this is cleared in `on_finalize` and Frame optimizes `None` values to be empty values.
             *
             * As a `bool`, `set(false)` and `remove()` both lead to the next `get()` being false, but one
             * of them writes to the trie and one does not. This confusion makes `Option<()>` more suitable
             * for the semantics of this variable.
             */
            HasInitialized: StorageDescriptor<[], undefined, true>;
            /**
             * Buffered session changes along with the block number at which they should be applied.
             *
             * Typically this will be empty or one element long. Apart from that this item never hits
             * the storage.
             *
             * However this is a `Vec` regardless to handle various edge cases that may occur at runtime
             * upgrade boundaries or if governance intervenes.
             */
            BufferedSessionChanges: StorageDescriptor<[], Anonymize<I14hoekog5s49k>, false>;
        },
        {
            /**
             *See [`Pallet::force_approve`].
             */
            force_approve: TxDescriptor<Anonymize<I85icj2qbjeqbe>>;
        },
        {},
        {},
        {}
    ];
    Dmp: [
        {
            /**
             * The downward messages addressed for a certain para.
             */
            DownwardMessageQueues: StorageDescriptor<[Key: number], Anonymize<I6ljjd4b5fa4ov>, false>;
            /**
             * A mapping that stores the downward message queue MQC head for each para.
             *
             * Each link in this chain has a form:
             * `(prev_head, B, H(M))`, where
             * - `prev_head`: is the previous head hash or zero if none.
             * - `B`: is the relay-chain block number in which a message was appended.
             * - `H(M)`: is the hash of the message being appended.
             */
            DownwardMessageQueueHeads: StorageDescriptor<[Key: number], Binary, false>;
            /**
             * The factor to multiply the base delivery fee by.
             */
            DeliveryFeeFactor: StorageDescriptor<[Key: number], bigint, false>;
        },
        {},
        {},
        {},
        {}
    ];
    Hrmp: [
        {
            /**
             * The set of pending HRMP open channel requests.
             *
             * The set is accompanied by a list for iteration.
             *
             * Invariant:
             * - There are no channels that exists in list but not in the set and vice versa.
             */
            HrmpOpenChannelRequests: StorageDescriptor<[Key: Anonymize<I50mrcbubp554e>], Anonymize<Ibhmrlkcu01imb>, true>;
            /**
            
             */
            HrmpOpenChannelRequestsList: StorageDescriptor<[], Anonymize<Id43g4eveajpkl>, false>;
            /**
             * This mapping tracks how many open channel requests are initiated by a given sender para.
             * Invariant: `HrmpOpenChannelRequests` should contain the same number of items that has
             * `(X, _)` as the number of `HrmpOpenChannelRequestCount` for `X`.
             */
            HrmpOpenChannelRequestCount: StorageDescriptor<[Key: number], number, false>;
            /**
             * This mapping tracks how many open channel requests were accepted by a given recipient para.
             * Invariant: `HrmpOpenChannelRequests` should contain the same number of items `(_, X)` with
             * `confirmed` set to true, as the number of `HrmpAcceptedChannelRequestCount` for `X`.
             */
            HrmpAcceptedChannelRequestCount: StorageDescriptor<[Key: number], number, false>;
            /**
             * A set of pending HRMP close channel requests that are going to be closed during the session
             * change. Used for checking if a given channel is registered for closure.
             *
             * The set is accompanied by a list for iteration.
             *
             * Invariant:
             * - There are no channels that exists in list but not in the set and vice versa.
             */
            HrmpCloseChannelRequests: StorageDescriptor<[Key: Anonymize<I50mrcbubp554e>], undefined, true>;
            /**
            
             */
            HrmpCloseChannelRequestsList: StorageDescriptor<[], Anonymize<Id43g4eveajpkl>, false>;
            /**
             * The HRMP watermark associated with each para.
             * Invariant:
             * - each para `P` used here as a key should satisfy `Paras::is_valid_para(P)` within a
             *   session.
             */
            HrmpWatermarks: StorageDescriptor<[Key: number], number, true>;
            /**
             * HRMP channel data associated with each para.
             * Invariant:
             * - each participant in the channel should satisfy `Paras::is_valid_para(P)` within a session.
             */
            HrmpChannels: StorageDescriptor<[Key: Anonymize<I50mrcbubp554e>], Anonymize<I6u4labiv1bntm>, true>;
            /**
             * Ingress/egress indexes allow to find all the senders and receivers given the opposite side.
             * I.e.
             *
             * (a) ingress index allows to find all the senders for a given recipient.
             * (b) egress index allows to find all the recipients for a given sender.
             *
             * Invariants:
             * - for each ingress index entry for `P` each item `I` in the index should present in
             *   `HrmpChannels` as `(I, P)`.
             * - for each egress index entry for `P` each item `E` in the index should present in
             *   `HrmpChannels` as `(P, E)`.
             * - there should be no other dangling channels in `HrmpChannels`.
             * - the vectors are sorted.
             */
            HrmpIngressChannelsIndex: StorageDescriptor<[Key: number], Anonymize<Icgljjb6j82uhn>, false>;
            /**
            
             */
            HrmpEgressChannelsIndex: StorageDescriptor<[Key: number], Anonymize<Icgljjb6j82uhn>, false>;
            /**
             * Storage for the messages for each channel.
             * Invariant: cannot be non-empty if the corresponding channel in `HrmpChannels` is `None`.
             */
            HrmpChannelContents: StorageDescriptor<[Key: Anonymize<I50mrcbubp554e>], Anonymize<Iev3u09i2vqn93>, false>;
            /**
             * Maintains a mapping that can be used to answer the question: What paras sent a message at
             * the given block number for a given receiver. Invariants:
             * - The inner `Vec<ParaId>` is never empty.
             * - The inner `Vec<ParaId>` cannot store two same `ParaId`.
             * - The outer vector is sorted ascending by block number and cannot store two items with the
             *   same block number.
             */
            HrmpChannelDigests: StorageDescriptor<[Key: number], Anonymize<I9olhgo2o08h7b>, false>;
        },
        {
            /**
             *See [`Pallet::hrmp_init_open_channel`].
             */
            hrmp_init_open_channel: TxDescriptor<Anonymize<Ibuhbp68e6tkct>>;
            /**
             *See [`Pallet::hrmp_accept_open_channel`].
             */
            hrmp_accept_open_channel: TxDescriptor<Anonymize<Idrevppfiubhve>>;
            /**
             *See [`Pallet::hrmp_close_channel`].
             */
            hrmp_close_channel: TxDescriptor<Anonymize<I9s2h36kr71vk9>>;
            /**
             *See [`Pallet::force_clean_hrmp`].
             */
            force_clean_hrmp: TxDescriptor<Anonymize<I4lkbiubo9ogq9>>;
            /**
             *See [`Pallet::force_process_hrmp_open`].
             */
            force_process_hrmp_open: TxDescriptor<Anonymize<Id1baei7m8gkhk>>;
            /**
             *See [`Pallet::force_process_hrmp_close`].
             */
            force_process_hrmp_close: TxDescriptor<Anonymize<Id1baei7m8gkhk>>;
            /**
             *See [`Pallet::hrmp_cancel_open_request`].
             */
            hrmp_cancel_open_request: TxDescriptor<Anonymize<I96ftepqm4vs7m>>;
            /**
             *See [`Pallet::force_open_hrmp_channel`].
             */
            force_open_hrmp_channel: TxDescriptor<Anonymize<Ic3430470j4mbv>>;
            /**
             *See [`Pallet::establish_system_channel`].
             */
            establish_system_channel: TxDescriptor<Anonymize<I50mrcbubp554e>>;
            /**
             *See [`Pallet::poke_channel_deposits`].
             */
            poke_channel_deposits: TxDescriptor<Anonymize<I50mrcbubp554e>>;
        },
        {
            /**
             *Open HRMP channel requested.
             */
            OpenChannelRequested: PlainDescriptor<Anonymize<Id2bej717ckub0>>;
            /**
             *An HRMP channel request sent by the receiver was canceled by either party.
             */
            OpenChannelCanceled: PlainDescriptor<Anonymize<I545vo2e86o5i4>>;
            /**
             *Open HRMP channel accepted.
             */
            OpenChannelAccepted: PlainDescriptor<Anonymize<I50mrcbubp554e>>;
            /**
             *HRMP channel closed.
             */
            ChannelClosed: PlainDescriptor<Anonymize<I545vo2e86o5i4>>;
            /**
             *An HRMP channel was opened via Root origin.
             */
            HrmpChannelForceOpened: PlainDescriptor<Anonymize<Id2bej717ckub0>>;
            /**
             *An HRMP channel was opened between two system chains.
             */
            HrmpSystemChannelOpened: PlainDescriptor<Anonymize<Id2bej717ckub0>>;
            /**
             *An HRMP channel's deposits were updated.
             */
            OpenChannelDepositsUpdated: PlainDescriptor<Anonymize<I50mrcbubp554e>>;
        },
        {
            /**
             *The sender tried to open a channel to themselves.
             */
            OpenHrmpChannelToSelf: PlainDescriptor<undefined>;
            /**
             *The recipient is not a valid para.
             */
            OpenHrmpChannelInvalidRecipient: PlainDescriptor<undefined>;
            /**
             *The requested capacity is zero.
             */
            OpenHrmpChannelZeroCapacity: PlainDescriptor<undefined>;
            /**
             *The requested capacity exceeds the global limit.
             */
            OpenHrmpChannelCapacityExceedsLimit: PlainDescriptor<undefined>;
            /**
             *The requested maximum message size is 0.
             */
            OpenHrmpChannelZeroMessageSize: PlainDescriptor<undefined>;
            /**
             *The open request requested the message size that exceeds the global limit.
             */
            OpenHrmpChannelMessageSizeExceedsLimit: PlainDescriptor<undefined>;
            /**
             *The channel already exists
             */
            OpenHrmpChannelAlreadyExists: PlainDescriptor<undefined>;
            /**
             *There is already a request to open the same channel.
             */
            OpenHrmpChannelAlreadyRequested: PlainDescriptor<undefined>;
            /**
             *The sender already has the maximum number of allowed outbound channels.
             */
            OpenHrmpChannelLimitExceeded: PlainDescriptor<undefined>;
            /**
             *The channel from the sender to the origin doesn't exist.
             */
            AcceptHrmpChannelDoesntExist: PlainDescriptor<undefined>;
            /**
             *The channel is already confirmed.
             */
            AcceptHrmpChannelAlreadyConfirmed: PlainDescriptor<undefined>;
            /**
             *The recipient already has the maximum number of allowed inbound channels.
             */
            AcceptHrmpChannelLimitExceeded: PlainDescriptor<undefined>;
            /**
             *The origin tries to close a channel where it is neither the sender nor the recipient.
             */
            CloseHrmpChannelUnauthorized: PlainDescriptor<undefined>;
            /**
             *The channel to be closed doesn't exist.
             */
            CloseHrmpChannelDoesntExist: PlainDescriptor<undefined>;
            /**
             *The channel close request is already requested.
             */
            CloseHrmpChannelAlreadyUnderway: PlainDescriptor<undefined>;
            /**
             *Canceling is requested by neither the sender nor recipient of the open channel request.
             */
            CancelHrmpOpenChannelUnauthorized: PlainDescriptor<undefined>;
            /**
             *The open request doesn't exist.
             */
            OpenHrmpChannelDoesntExist: PlainDescriptor<undefined>;
            /**
             *Cannot cancel an HRMP open channel request because it is already confirmed.
             */
            OpenHrmpChannelAlreadyConfirmed: PlainDescriptor<undefined>;
            /**
             *The provided witness data is wrong.
             */
            WrongWitness: PlainDescriptor<undefined>;
            /**
             *The channel between these two chains cannot be authorized.
             */
            ChannelCreationNotAuthorized: PlainDescriptor<undefined>;
        },
        {}
    ];
    ParaSessionInfo: [
        {
            /**
             * Assignment keys for the current session.
             * Note that this API is private due to it being prone to 'off-by-one' at session boundaries.
             * When in doubt, use `Sessions` API instead.
             */
            AssignmentKeysUnsafe: StorageDescriptor<[], Anonymize<Idhnf6rtqoslea>, false>;
            /**
             * The earliest session for which previous session info is stored.
             */
            EarliestStoredSession: StorageDescriptor<[], number, false>;
            /**
             * Session information in a rolling window.
             * Should have an entry in range `EarliestStoredSession..=CurrentSessionIndex`.
             * Does not have any entries before the session index in the first session change notification.
             */
            Sessions: StorageDescriptor<[Key: number], Anonymize<I7k9oi9p83j43l>, true>;
            /**
             * The validator account keys of the validators actively participating in parachain consensus.
             */
            AccountKeys: StorageDescriptor<[Key: number], Anonymize<Ia2lhg7l2hilo3>, true>;
            /**
             * Executor parameter set for a given session index
             */
            SessionExecutorParams: StorageDescriptor<[Key: number], Anonymize<I6sbufrhmgqdb6>, true>;
        },
        {},
        {},
        {},
        {}
    ];
    ParasDisputes: [
        {
            /**
             * The last pruned session, if any. All data stored by this module
             * references sessions.
             */
            LastPrunedSession: StorageDescriptor<[], number, true>;
            /**
             * All ongoing or concluded disputes for the last several sessions.
             */
            Disputes: StorageDescriptor<Anonymize<If89923vhoiaim>, Anonymize<I87u7jalc0lhah>, true>;
            /**
             * Backing votes stored for each dispute.
             * This storage is used for slashing.
             */
            BackersOnDisputes: StorageDescriptor<Anonymize<If89923vhoiaim>, Anonymize<Icgljjb6j82uhn>, true>;
            /**
             * All included blocks on the chain, as well as the block number in this chain that
             * should be reverted back to if the candidate is disputed and determined to be invalid.
             */
            Included: StorageDescriptor<Anonymize<If89923vhoiaim>, number, true>;
            /**
             * Whether the chain is frozen. Starts as `None`. When this is `Some`,
             * the chain will not accept any new parachain blocks for backing or inclusion,
             * and its value indicates the last valid block number in the chain.
             * It can only be set back to `None` by governance intervention.
             */
            Frozen: StorageDescriptor<[], Anonymize<I4arjljr6dpflb>, false>;
        },
        {
            /**
             *See [`Pallet::force_unfreeze`].
             */
            force_unfreeze: TxDescriptor<undefined>;
        },
        {
            /**
             *A dispute has been initiated. \[candidate hash, dispute location\]
             */
            DisputeInitiated: PlainDescriptor<Anonymize<I3o099fcusuh31>>;
            /**
             *A dispute has concluded for or against a candidate.
             *`\[para id, candidate hash, dispute result\]`
             */
            DisputeConcluded: PlainDescriptor<Anonymize<Ifr2e7vm3bun8k>>;
            /**
             *A dispute has concluded with supermajority against a candidate.
             *Block authors should no longer build on top of this head and should
             *instead revert the block at the given height. This should be the
             *number of the child of the last known valid block in the chain.
             */
            Revert: PlainDescriptor<number>;
        },
        {
            /**
             *Duplicate dispute statement sets provided.
             */
            DuplicateDisputeStatementSets: PlainDescriptor<undefined>;
            /**
             *Ancient dispute statement provided.
             */
            AncientDisputeStatement: PlainDescriptor<undefined>;
            /**
             *Validator index on statement is out of bounds for session.
             */
            ValidatorIndexOutOfBounds: PlainDescriptor<undefined>;
            /**
             *Invalid signature on statement.
             */
            InvalidSignature: PlainDescriptor<undefined>;
            /**
             *Validator vote submitted more than once to dispute.
             */
            DuplicateStatement: PlainDescriptor<undefined>;
            /**
             *A dispute where there are only votes on one side.
             */
            SingleSidedDispute: PlainDescriptor<undefined>;
            /**
             *A dispute vote from a malicious backer.
             */
            MaliciousBacker: PlainDescriptor<undefined>;
            /**
             *No backing votes were provides along dispute statements.
             */
            MissingBackingVotes: PlainDescriptor<undefined>;
            /**
             *Unconfirmed dispute statement sets provided.
             */
            UnconfirmedDispute: PlainDescriptor<undefined>;
        },
        {}
    ];
    ParasSlashing: [
        {
            /**
             * Validators pending dispute slashes.
             */
            UnappliedSlashes: StorageDescriptor<Anonymize<If89923vhoiaim>, Anonymize<I3g2jv3qmtkrbe>, true>;
            /**
             * `ValidatorSetCount` per session.
             */
            ValidatorSetCounts: StorageDescriptor<[Key: number], number, true>;
        },
        {
            /**
             *See [`Pallet::report_dispute_lost_unsigned`].
             */
            report_dispute_lost_unsigned: TxDescriptor<Anonymize<I1ur1874hp9ar5>>;
        },
        {},
        {
            /**
             *The key ownership proof is invalid.
             */
            InvalidKeyOwnershipProof: PlainDescriptor<undefined>;
            /**
             *The session index is too old or invalid.
             */
            InvalidSessionIndex: PlainDescriptor<undefined>;
            /**
             *The candidate hash is invalid.
             */
            InvalidCandidateHash: PlainDescriptor<undefined>;
            /**
             *There is no pending slash for the given validator index and time
             *slot.
             */
            InvalidValidatorIndex: PlainDescriptor<undefined>;
            /**
             *The validator index does not match the validator id.
             */
            ValidatorIndexIdMismatch: PlainDescriptor<undefined>;
            /**
             *The given slashing report is valid but already previously reported.
             */
            DuplicateSlashingReport: PlainDescriptor<undefined>;
        },
        {}
    ];
    ParaAssignmentProvider: [{}, {}, {}, {}, {}];
    Registrar: [
        {
            /**
             * Pending swap operations.
             */
            PendingSwap: StorageDescriptor<[Key: number], number, true>;
            /**
             * Amount held on deposit for each para and the original depositor.
             *
             * The given account ID is responsible for registering the code and initial head data, but may
             * only do so if it isn't yet registered. (After that, it's up to governance to do so.)
             */
            Paras: StorageDescriptor<[Key: number], Anonymize<I3av628q6dt6mq>, true>;
            /**
             * The next free `ParaId`.
             */
            NextFreeParaId: StorageDescriptor<[], number, false>;
        },
        {
            /**
             *See [`Pallet::register`].
             */
            register: TxDescriptor<Anonymize<I7mf0sij342109>>;
            /**
             *See [`Pallet::force_register`].
             */
            force_register: TxDescriptor<Anonymize<Ibvirp862qkkup>>;
            /**
             *See [`Pallet::deregister`].
             */
            deregister: TxDescriptor<Anonymize<Ic5b47dj4coa3r>>;
            /**
             *See [`Pallet::swap`].
             */
            swap: TxDescriptor<Anonymize<Idehabrqi23sc0>>;
            /**
             *See [`Pallet::remove_lock`].
             */
            remove_lock: TxDescriptor<Anonymize<Iaus4cb3drhu9q>>;
            /**
             *See [`Pallet::reserve`].
             */
            reserve: TxDescriptor<undefined>;
            /**
             *See [`Pallet::add_lock`].
             */
            add_lock: TxDescriptor<Anonymize<Iaus4cb3drhu9q>>;
            /**
             *See [`Pallet::schedule_code_upgrade`].
             */
            schedule_code_upgrade: TxDescriptor<Anonymize<I1k3urvkqqshbc>>;
            /**
             *See [`Pallet::set_current_head`].
             */
            set_current_head: TxDescriptor<Anonymize<I2ff0ffsh15vej>>;
        },
        {
            /**
            
             */
            Registered: PlainDescriptor<Anonymize<Ibs22tt76qp5bi>>;
            /**
            
             */
            Deregistered: PlainDescriptor<Anonymize<I37r4bdai8o9mp>>;
            /**
            
             */
            Reserved: PlainDescriptor<Anonymize<Idn2ghub1o4i40>>;
            /**
            
             */
            Swapped: PlainDescriptor<Anonymize<I48u78djt89dod>>;
        },
        {
            /**
             *The ID is not registered.
             */
            NotRegistered: PlainDescriptor<undefined>;
            /**
             *The ID is already registered.
             */
            AlreadyRegistered: PlainDescriptor<undefined>;
            /**
             *The caller is not the owner of this Id.
             */
            NotOwner: PlainDescriptor<undefined>;
            /**
             *Invalid para code size.
             */
            CodeTooLarge: PlainDescriptor<undefined>;
            /**
             *Invalid para head data size.
             */
            HeadDataTooLarge: PlainDescriptor<undefined>;
            /**
             *Para is not a Parachain.
             */
            NotParachain: PlainDescriptor<undefined>;
            /**
             *Para is not a Parathread (on-demand parachain).
             */
            NotParathread: PlainDescriptor<undefined>;
            /**
             *Cannot deregister para
             */
            CannotDeregister: PlainDescriptor<undefined>;
            /**
             *Cannot schedule downgrade of lease holding parachain to on-demand parachain
             */
            CannotDowngrade: PlainDescriptor<undefined>;
            /**
             *Cannot schedule upgrade of on-demand parachain to lease holding parachain
             */
            CannotUpgrade: PlainDescriptor<undefined>;
            /**
             *Para is locked from manipulation by the manager. Must use parachain or relay chain
             *governance.
             */
            ParaLocked: PlainDescriptor<undefined>;
            /**
             *The ID given for registration has not been reserved.
             */
            NotReserved: PlainDescriptor<undefined>;
            /**
             *Registering parachain with empty code is not allowed.
             */
            EmptyCode: PlainDescriptor<undefined>;
            /**
             *Cannot perform a parachain slot / lifecycle swap. Check that the state of both paras
             *are correct for the swap to work.
             */
            CannotSwap: PlainDescriptor<undefined>;
        },
        {
            /**
             * The deposit to be paid to run a on-demand parachain.
             * This should include the cost for storing the genesis head and validation code.
             */
            ParaDeposit: PlainDescriptor<bigint>;
            /**
             * The deposit to be paid per byte stored on chain.
             */
            DataDepositPerByte: PlainDescriptor<bigint>;
        }
    ];
    Slots: [
        {
            /**
             * Amounts held on deposit for each (possibly future) leased parachain.
             *
             * The actual amount locked on its behalf by any account at any time is the maximum of the
             * second values of the items in this list whose first value is the account.
             *
             * The first item in the list is the amount locked for the current Lease Period. Following
             * items are for the subsequent lease periods.
             *
             * The default value (an empty list) implies that the parachain no longer exists (or never
             * existed) as far as this pallet is concerned.
             *
             * If a parachain doesn't exist *yet* but is scheduled to exist in the future, then it
             * will be left-padded with one or more `None`s to denote the fact that nothing is held on
             * deposit for the non-existent chain currently, but is held at some point in the future.
             *
             * It is illegal for a `None` value to trail in the list.
             */
            Leases: StorageDescriptor<[Key: number], Anonymize<Ifmaahl40gom3g>, false>;
        },
        {
            /**
             *See [`Pallet::force_lease`].
             */
            force_lease: TxDescriptor<Anonymize<Idfpo6162k0hq>>;
            /**
             *See [`Pallet::clear_all_leases`].
             */
            clear_all_leases: TxDescriptor<Anonymize<Iaus4cb3drhu9q>>;
            /**
             *See [`Pallet::trigger_onboard`].
             */
            trigger_onboard: TxDescriptor<Anonymize<Iaus4cb3drhu9q>>;
        },
        {
            /**
             *A new `[lease_period]` is beginning.
             */
            NewLeasePeriod: PlainDescriptor<Anonymize<Ib85m5kfbepu2t>>;
            /**
             *A para has won the right to a continuous set of lease periods as a parachain.
             *First balance is any extra amount reserved on top of the para's existing deposit.
             *Second balance is the total amount reserved.
             */
            Leased: PlainDescriptor<Anonymize<Idaml5bdhsfcsl>>;
        },
        {
            /**
             *The parachain ID is not onboarding.
             */
            ParaNotOnboarding: PlainDescriptor<undefined>;
            /**
             *There was an error with the lease.
             */
            LeaseError: PlainDescriptor<undefined>;
        },
        {
            /**
             * The number of blocks over which a single period lasts.
             */
            LeasePeriod: PlainDescriptor<number>;
            /**
             * The number of blocks to offset each lease period by.
             */
            LeaseOffset: PlainDescriptor<number>;
        }
    ];
    Auctions: [
        {
            /**
             * Number of auctions started so far.
             */
            AuctionCounter: StorageDescriptor<[], number, false>;
            /**
             * Information relating to the current auction, if there is one.
             *
             * The first item in the tuple is the lease period index that the first of the four
             * contiguous lease periods on auction is for. The second is the block number when the
             * auction will "begin to end", i.e. the first block of the Ending Period of the auction.
             */
            AuctionInfo: StorageDescriptor<[], Anonymize<I5g2vv0ckl2m8b>, true>;
            /**
             * Amounts currently reserved in the accounts of the bidders currently winning
             * (sub-)ranges.
             */
            ReservedAmounts: StorageDescriptor<[Key: Anonymize<I6ouflveob4eli>], bigint, true>;
            /**
             * The winning bids for each of the 10 ranges at each sample in the final Ending Period of
             * the current auction. The map's key is the 0-based index into the Sample Size. The
             * first sample of the ending period is 0; the last is `Sample Size - 1`.
             */
            Winning: StorageDescriptor<[Key: number], Anonymize<I70iuri2ilha1f>, true>;
        },
        {
            /**
             *See [`Pallet::new_auction`].
             */
            new_auction: TxDescriptor<Anonymize<I19hvnphoaj44l>>;
            /**
             *See [`Pallet::bid`].
             */
            bid: TxDescriptor<Anonymize<I1ng31ej27mh4k>>;
            /**
             *See [`Pallet::cancel_auction`].
             */
            cancel_auction: TxDescriptor<undefined>;
        },
        {
            /**
             *An auction started. Provides its index and the block number where it will begin to
             *close and the first lease period of the quadruplet that is auctioned.
             */
            AuctionStarted: PlainDescriptor<Anonymize<Ieec0cu336gteb>>;
            /**
             *An auction ended. All funds become unreserved.
             */
            AuctionClosed: PlainDescriptor<Anonymize<I815d5k4ij85nv>>;
            /**
             *Funds were reserved for a winning bid. First balance is the extra amount reserved.
             *Second is the total.
             */
            Reserved: PlainDescriptor<Anonymize<Ifi98fgi9o46v7>>;
            /**
             *Funds were unreserved since bidder is no longer active. `[bidder, amount]`
             */
            Unreserved: PlainDescriptor<Anonymize<Ic0oj9tok33uap>>;
            /**
             *Someone attempted to lease the same slot twice for a parachain. The amount is held in
             *reserve but no parachain slot has been leased.
             */
            ReserveConfiscated: PlainDescriptor<Anonymize<I3tdutpfjuk32j>>;
            /**
             *A new bid has been accepted as the current winner.
             */
            BidAccepted: PlainDescriptor<Anonymize<I1esdujrkdacpb>>;
            /**
             *The winning offset was chosen for an auction. This will map into the `Winning` storage
             *map.
             */
            WinningOffset: PlainDescriptor<Anonymize<I9g1d820jf9m2s>>;
        },
        {
            /**
             *This auction is already in progress.
             */
            AuctionInProgress: PlainDescriptor<undefined>;
            /**
             *The lease period is in the past.
             */
            LeasePeriodInPast: PlainDescriptor<undefined>;
            /**
             *Para is not registered
             */
            ParaNotRegistered: PlainDescriptor<undefined>;
            /**
             *Not a current auction.
             */
            NotCurrentAuction: PlainDescriptor<undefined>;
            /**
             *Not an auction.
             */
            NotAuction: PlainDescriptor<undefined>;
            /**
             *Auction has already ended.
             */
            AuctionEnded: PlainDescriptor<undefined>;
            /**
             *The para is already leased out for part of this range.
             */
            AlreadyLeasedOut: PlainDescriptor<undefined>;
        },
        {
            /**
             * The number of blocks over which an auction may be retroactively ended.
             */
            EndingPeriod: PlainDescriptor<number>;
            /**
             * The length of each sample to take during the ending period.
             *
             * `EndingPeriod` / `SampleLength` = Total # of Samples
             */
            SampleLength: PlainDescriptor<number>;
            /**
            
             */
            SlotRangeCount: PlainDescriptor<number>;
            /**
            
             */
            LeasePeriodsPerSlot: PlainDescriptor<number>;
        }
    ];
    Crowdloan: [
        {
            /**
             * Info on all of the funds.
             */
            Funds: StorageDescriptor<[Key: number], Anonymize<I2neqklu8gtd27>, true>;
            /**
             * The funds that have had additional contributions during the last block. This is used
             * in order to determine which funds should submit new or updated bids.
             */
            NewRaise: StorageDescriptor<[], Anonymize<Icgljjb6j82uhn>, false>;
            /**
             * The number of auctions that have entered into their ending period so far.
             */
            EndingsCount: StorageDescriptor<[], number, false>;
            /**
             * Tracker for the next available fund index
             */
            NextFundIndex: StorageDescriptor<[], number, false>;
        },
        {
            /**
             *See [`Pallet::create`].
             */
            create: TxDescriptor<Anonymize<I3js6c9fubdele>>;
            /**
             *See [`Pallet::contribute`].
             */
            contribute: TxDescriptor<Anonymize<I6n5jj22t7mm7i>>;
            /**
             *See [`Pallet::withdraw`].
             */
            withdraw: TxDescriptor<Anonymize<Ia1u3jll6a06ae>>;
            /**
             *See [`Pallet::refund`].
             */
            refund: TxDescriptor<Anonymize<I666bl2fqjkejo>>;
            /**
             *See [`Pallet::dissolve`].
             */
            dissolve: TxDescriptor<Anonymize<I666bl2fqjkejo>>;
            /**
             *See [`Pallet::edit`].
             */
            edit: TxDescriptor<Anonymize<I3js6c9fubdele>>;
            /**
             *See [`Pallet::add_memo`].
             */
            add_memo: TxDescriptor<Anonymize<I7cl9esn1l72m7>>;
            /**
             *See [`Pallet::poke`].
             */
            poke: TxDescriptor<Anonymize<I666bl2fqjkejo>>;
            /**
             *See [`Pallet::contribute_all`].
             */
            contribute_all: TxDescriptor<Anonymize<I3k27o64k49es2>>;
        },
        {
            /**
             *Create a new crowdloaning campaign.
             */
            Created: PlainDescriptor<Anonymize<I37r4bdai8o9mp>>;
            /**
             *Contributed to a crowd sale.
             */
            Contributed: PlainDescriptor<Anonymize<I8ve4g3egaln6a>>;
            /**
             *Withdrew full balance of a contributor.
             */
            Withdrew: PlainDescriptor<Anonymize<I8ve4g3egaln6a>>;
            /**
             *The loans in a fund have been partially dissolved, i.e. there are some left
             *over child keys that still need to be killed.
             */
            PartiallyRefunded: PlainDescriptor<Anonymize<I37r4bdai8o9mp>>;
            /**
             *All loans in a fund have been refunded.
             */
            AllRefunded: PlainDescriptor<Anonymize<I37r4bdai8o9mp>>;
            /**
             *Fund is dissolved.
             */
            Dissolved: PlainDescriptor<Anonymize<I37r4bdai8o9mp>>;
            /**
             *The result of trying to submit a new bid to the Slots pallet.
             */
            HandleBidResult: PlainDescriptor<Anonymize<If9e3ujpsfl4g7>>;
            /**
             *The configuration to a crowdloan has been edited.
             */
            Edited: PlainDescriptor<Anonymize<I37r4bdai8o9mp>>;
            /**
             *A memo has been updated.
             */
            MemoUpdated: PlainDescriptor<Anonymize<If4hvqaeoqq5us>>;
            /**
             *A parachain has been moved to `NewRaise`
             */
            AddedToNewRaise: PlainDescriptor<Anonymize<I37r4bdai8o9mp>>;
        },
        {
            /**
             *The current lease period is more than the first lease period.
             */
            FirstPeriodInPast: PlainDescriptor<undefined>;
            /**
             *The first lease period needs to at least be less than 3 `max_value`.
             */
            FirstPeriodTooFarInFuture: PlainDescriptor<undefined>;
            /**
             *Last lease period must be greater than first lease period.
             */
            LastPeriodBeforeFirstPeriod: PlainDescriptor<undefined>;
            /**
             *The last lease period cannot be more than 3 periods after the first period.
             */
            LastPeriodTooFarInFuture: PlainDescriptor<undefined>;
            /**
             *The campaign ends before the current block number. The end must be in the future.
             */
            CannotEndInPast: PlainDescriptor<undefined>;
            /**
             *The end date for this crowdloan is not sensible.
             */
            EndTooFarInFuture: PlainDescriptor<undefined>;
            /**
             *There was an overflow.
             */
            Overflow: PlainDescriptor<undefined>;
            /**
             *The contribution was below the minimum, `MinContribution`.
             */
            ContributionTooSmall: PlainDescriptor<undefined>;
            /**
             *Invalid fund index.
             */
            InvalidParaId: PlainDescriptor<undefined>;
            /**
             *Contributions exceed maximum amount.
             */
            CapExceeded: PlainDescriptor<undefined>;
            /**
             *The contribution period has already ended.
             */
            ContributionPeriodOver: PlainDescriptor<undefined>;
            /**
             *The origin of this call is invalid.
             */
            InvalidOrigin: PlainDescriptor<undefined>;
            /**
             *This crowdloan does not correspond to a parachain.
             */
            NotParachain: PlainDescriptor<undefined>;
            /**
             *This parachain lease is still active and retirement cannot yet begin.
             */
            LeaseActive: PlainDescriptor<undefined>;
            /**
             *This parachain's bid or lease is still active and withdraw cannot yet begin.
             */
            BidOrLeaseActive: PlainDescriptor<undefined>;
            /**
             *The crowdloan has not yet ended.
             */
            FundNotEnded: PlainDescriptor<undefined>;
            /**
             *There are no contributions stored in this crowdloan.
             */
            NoContributions: PlainDescriptor<undefined>;
            /**
             *The crowdloan is not ready to dissolve. Potentially still has a slot or in retirement
             *period.
             */
            NotReadyToDissolve: PlainDescriptor<undefined>;
            /**
             *Invalid signature.
             */
            InvalidSignature: PlainDescriptor<undefined>;
            /**
             *The provided memo is too large.
             */
            MemoTooLarge: PlainDescriptor<undefined>;
            /**
             *The fund is already in `NewRaise`
             */
            AlreadyInNewRaise: PlainDescriptor<undefined>;
            /**
             *No contributions allowed during the VRF delay
             */
            VrfDelayInProgress: PlainDescriptor<undefined>;
            /**
             *A lease period has not started yet, due to an offset in the starting block.
             */
            NoLeasePeriod: PlainDescriptor<undefined>;
        },
        {
            /**
             * `PalletId` for the crowdloan pallet. An appropriate value could be
             * `PalletId(*b"py/cfund")`
             */
            PalletId: PlainDescriptor<Binary>;
            /**
             * The minimum amount that may be contributed into a crowdloan. Should almost certainly be
             * at least `ExistentialDeposit`.
             */
            MinContribution: PlainDescriptor<bigint>;
            /**
             * Max number of storage keys to remove per extrinsic call.
             */
            RemoveKeysLimit: PlainDescriptor<number>;
        }
    ];
    XcmPallet: [
        {
            /**
             * The latest available query index.
             */
            QueryCounter: StorageDescriptor<[], bigint, false>;
            /**
             * The ongoing queries.
             */
            Queries: StorageDescriptor<[Key: bigint], XcmPalletQueryStatus, true>;
            /**
             * The existing asset traps.
             *
             * Key is the blake2 256 hash of (origin, versioned `MultiAssets`) pair. Value is the number of
             * times this pair has been trapped (usually just 1 if it exists at all).
             */
            AssetTraps: StorageDescriptor<[Key: Binary], number, false>;
            /**
             * Default version to encode XCM when latest version of destination is unknown. If `None`,
             * then the destinations whose XCM version is unknown are considered unreachable.
             */
            SafeXcmVersion: StorageDescriptor<[], number, true>;
            /**
             * The Latest versions that we know various locations support.
             */
            SupportedVersion: StorageDescriptor<Anonymize<I46ggargfeekkj>, number, true>;
            /**
             * All locations that we have requested version notifications from.
             */
            VersionNotifiers: StorageDescriptor<Anonymize<I46ggargfeekkj>, bigint, true>;
            /**
             * The target locations that are subscribed to our version changes, as well as the most recent
             * of our versions we informed them of.
             */
            VersionNotifyTargets: StorageDescriptor<Anonymize<I46ggargfeekkj>, Anonymize<I7vlvrrl2pnbgk>, true>;
            /**
             * Destinations whose latest XCM version we would like to know. Duplicates not allowed, and
             * the `u32` counter is the number of times that a send to the destination has been attempted,
             * which is used as a prioritization.
             */
            VersionDiscoveryQueue: StorageDescriptor<[], Anonymize<Ibdqc639q3ofe0>, false>;
            /**
             * The current migration's stage, if any.
             */
            CurrentMigration: StorageDescriptor<[], XcmPalletVersionMigrationStage, true>;
            /**
             * Fungible assets which we know are locked on a remote chain.
             */
            RemoteLockedFungibles: StorageDescriptor<Anonymize<I61vn4ct4e1jjd>, Anonymize<Iaaeqd8puo95gs>, true>;
            /**
             * Fungible assets which we know are locked on this chain.
             */
            LockedFungibles: StorageDescriptor<[Key: SS58String], Anonymize<I64u7pb324isgb>, true>;
            /**
             * Global suspension state of the XCM executor.
             */
            XcmExecutionSuspended: StorageDescriptor<[], boolean, false>;
        },
        {
            /**
             *See [`Pallet::send`].
             */
            send: TxDescriptor<Anonymize<Icvpjofp09bmlh>>;
            /**
             *See [`Pallet::teleport_assets`].
             */
            teleport_assets: TxDescriptor<Anonymize<Ieeis6pj62kiu4>>;
            /**
             *See [`Pallet::reserve_transfer_assets`].
             */
            reserve_transfer_assets: TxDescriptor<Anonymize<Ieeis6pj62kiu4>>;
            /**
             *See [`Pallet::execute`].
             */
            execute: TxDescriptor<Anonymize<I53e0mdinhcvpm>>;
            /**
             *See [`Pallet::force_xcm_version`].
             */
            force_xcm_version: TxDescriptor<Anonymize<I732o5n04n5ohg>>;
            /**
             *See [`Pallet::force_default_xcm_version`].
             */
            force_default_xcm_version: TxDescriptor<Anonymize<Ic76kfh5ebqkpl>>;
            /**
             *See [`Pallet::force_subscribe_version_notify`].
             */
            force_subscribe_version_notify: TxDescriptor<Anonymize<I3pog27ittgi9g>>;
            /**
             *See [`Pallet::force_unsubscribe_version_notify`].
             */
            force_unsubscribe_version_notify: TxDescriptor<Anonymize<I3pog27ittgi9g>>;
            /**
             *See [`Pallet::limited_reserve_transfer_assets`].
             */
            limited_reserve_transfer_assets: TxDescriptor<Anonymize<Ifcceq8taolrca>>;
            /**
             *See [`Pallet::limited_teleport_assets`].
             */
            limited_teleport_assets: TxDescriptor<Anonymize<Ifcceq8taolrca>>;
            /**
             *See [`Pallet::force_suspension`].
             */
            force_suspension: TxDescriptor<Anonymize<Ibgm4rnf22lal1>>;
        },
        {
            /**
             *Execution of an XCM message was attempted.
             */
            Attempted: PlainDescriptor<Anonymize<I4e7dkr4hrus3u>>;
            /**
             *A XCM message was sent.
             */
            Sent: PlainDescriptor<Anonymize<Ia5b8kts5gt3p5>>;
            /**
             *Query response received which does not match a registered query. This may be because a
             *matching query was never registered, it may be because it is a duplicate response, or
             *because the query timed out.
             */
            UnexpectedResponse: PlainDescriptor<Anonymize<Ise9r0vrat2m6>>;
            /**
             *Query response has been received and is ready for taking with `take_response`. There is
             *no registered notification call.
             */
            ResponseReady: PlainDescriptor<Anonymize<I7kkbgm2llu2o3>>;
            /**
             *Query response has been received and query is removed. The registered notification has
             *been dispatched and executed successfully.
             */
            Notified: PlainDescriptor<Anonymize<I2uqmls7kcdnii>>;
            /**
             *Query response has been received and query is removed. The registered notification
             *could not be dispatched because the dispatch weight is greater than the maximum weight
             *originally budgeted by this runtime for the query result.
             */
            NotifyOverweight: PlainDescriptor<Anonymize<Idg69klialbkb8>>;
            /**
             *Query response has been received and query is removed. There was a general error with
             *dispatching the notification call.
             */
            NotifyDispatchError: PlainDescriptor<Anonymize<I2uqmls7kcdnii>>;
            /**
             *Query response has been received and query is removed. The dispatch was unable to be
             *decoded into a `Call`; this might be due to dispatch function having a signature which
             *is not `(origin, QueryId, Response)`.
             */
            NotifyDecodeFailed: PlainDescriptor<Anonymize<I2uqmls7kcdnii>>;
            /**
             *Expected query response has been received but the origin location of the response does
             *not match that expected. The query remains registered for a later, valid, response to
             *be received and acted upon.
             */
            InvalidResponder: PlainDescriptor<Anonymize<I9j133okge3c2>>;
            /**
             *Expected query response has been received but the expected origin location placed in
             *storage by this runtime previously cannot be decoded. The query remains registered.
             *
             *This is unexpected (since a location placed in storage in a previously executing
             *runtime should be readable prior to query timeout) and dangerous since the possibly
             *valid response will be dropped. Manual governance intervention is probably going to be
             *needed.
             */
            InvalidResponderVersion: PlainDescriptor<Anonymize<Ise9r0vrat2m6>>;
            /**
             *Received query response has been read and removed.
             */
            ResponseTaken: PlainDescriptor<Anonymize<I30pg328m00nr3>>;
            /**
             *Some assets have been placed in an asset trap.
             */
            AssetsTrapped: PlainDescriptor<Anonymize<I5qm1bvb2j3ap2>>;
            /**
             *An XCM version change notification message has been attempted to be sent.
             *
             *The cost of sending it (borne by the chain) is included.
             */
            VersionChangeNotified: PlainDescriptor<Anonymize<I95aqmsd6gjmqs>>;
            /**
             *The supported version of a location has been changed. This might be through an
             *automatic notification or a manual intervention.
             */
            SupportedVersionChanged: PlainDescriptor<Anonymize<I732o5n04n5ohg>>;
            /**
             *A given location which had a version change subscription was dropped owing to an error
             *sending the notification to it.
             */
            NotifyTargetSendFail: PlainDescriptor<Anonymize<Iarlf7ddo81fm5>>;
            /**
             *A given location which had a version change subscription was dropped owing to an error
             *migrating the location to our new XCM format.
             */
            NotifyTargetMigrationFail: PlainDescriptor<Anonymize<Ie9bjgclf7vho0>>;
            /**
             *Expected query response has been received but the expected querier location placed in
             *storage by this runtime previously cannot be decoded. The query remains registered.
             *
             *This is unexpected (since a location placed in storage in a previously executing
             *runtime should be readable prior to query timeout) and dangerous since the possibly
             *valid response will be dropped. Manual governance intervention is probably going to be
             *needed.
             */
            InvalidQuerierVersion: PlainDescriptor<Anonymize<Ise9r0vrat2m6>>;
            /**
             *Expected query response has been received but the querier location of the response does
             *not match the expected. The query remains registered for a later, valid, response to
             *be received and acted upon.
             */
            InvalidQuerier: PlainDescriptor<Anonymize<I7dm0nb8u3g2hv>>;
            /**
             *A remote has requested XCM version change notification from us and we have honored it.
             *A version information message is sent to them and its cost is included.
             */
            VersionNotifyStarted: PlainDescriptor<Anonymize<I5pnf8l8c1nkfk>>;
            /**
             *We have requested that a remote chain send us XCM version change notifications.
             */
            VersionNotifyRequested: PlainDescriptor<Anonymize<I5pnf8l8c1nkfk>>;
            /**
             *We have requested that a remote chain stops sending us XCM version change
             *notifications.
             */
            VersionNotifyUnrequested: PlainDescriptor<Anonymize<I5pnf8l8c1nkfk>>;
            /**
             *Fees were paid from a location for an operation (often for using `SendXcm`).
             */
            FeesPaid: PlainDescriptor<Anonymize<Ibknqphki4flb3>>;
            /**
             *Some assets have been claimed from an asset trap
             */
            AssetsClaimed: PlainDescriptor<Anonymize<I5qm1bvb2j3ap2>>;
        },
        {
            /**
             *The desired destination was unreachable, generally because there is a no way of routing
             *to it.
             */
            Unreachable: PlainDescriptor<undefined>;
            /**
             *There was some other issue (i.e. not to do with routing) in sending the message.
             *Perhaps a lack of space for buffering the message.
             */
            SendFailure: PlainDescriptor<undefined>;
            /**
             *The message execution fails the filter.
             */
            Filtered: PlainDescriptor<undefined>;
            /**
             *The message's weight could not be determined.
             */
            UnweighableMessage: PlainDescriptor<undefined>;
            /**
             *The destination `MultiLocation` provided cannot be inverted.
             */
            DestinationNotInvertible: PlainDescriptor<undefined>;
            /**
             *The assets to be sent are empty.
             */
            Empty: PlainDescriptor<undefined>;
            /**
             *Could not re-anchor the assets to declare the fees for the destination chain.
             */
            CannotReanchor: PlainDescriptor<undefined>;
            /**
             *Too many assets have been attempted for transfer.
             */
            TooManyAssets: PlainDescriptor<undefined>;
            /**
             *Origin is invalid for sending.
             */
            InvalidOrigin: PlainDescriptor<undefined>;
            /**
             *The version of the `Versioned` value used is not able to be interpreted.
             */
            BadVersion: PlainDescriptor<undefined>;
            /**
             *The given location could not be used (e.g. because it cannot be expressed in the
             *desired version of XCM).
             */
            BadLocation: PlainDescriptor<undefined>;
            /**
             *The referenced subscription could not be found.
             */
            NoSubscription: PlainDescriptor<undefined>;
            /**
             *The location is invalid since it already has a subscription from us.
             */
            AlreadySubscribed: PlainDescriptor<undefined>;
            /**
             *Invalid asset for the operation.
             */
            InvalidAsset: PlainDescriptor<undefined>;
            /**
             *The owner does not own (all) of the asset that they wish to do the operation on.
             */
            LowBalance: PlainDescriptor<undefined>;
            /**
             *The asset owner has too many locks on the asset.
             */
            TooManyLocks: PlainDescriptor<undefined>;
            /**
             *The given account is not an identifiable sovereign account for any location.
             */
            AccountNotSovereign: PlainDescriptor<undefined>;
            /**
             *The operation required fees to be paid which the initiator could not meet.
             */
            FeesNotMet: PlainDescriptor<undefined>;
            /**
             *A remote lock with the corresponding data could not be found.
             */
            LockNotFound: PlainDescriptor<undefined>;
            /**
             *The unlock operation cannot succeed because there are still consumers of the lock.
             */
            InUse: PlainDescriptor<undefined>;
        },
        {}
    ];
    MessageQueue: [
        {
            /**
             * The index of the first and last (non-empty) pages.
             */
            BookStateFor: StorageDescriptor<[Key: ParachainsInclusionAggregateMessageOrigin], Anonymize<Ic9ppo8st33eqb>, false>;
            /**
             * The origin at which we should begin servicing.
             */
            ServiceHead: StorageDescriptor<[], ParachainsInclusionAggregateMessageOrigin, true>;
            /**
             * The map of page indices to pages.
             */
            Pages: StorageDescriptor<Anonymize<Ibg270mmpf1f2q>, Anonymize<I53esa2ms463bk>, true>;
        },
        {
            /**
             *See [`Pallet::reap_page`].
             */
            reap_page: TxDescriptor<Anonymize<I3f1tq7m3kurig>>;
            /**
             *See [`Pallet::execute_overweight`].
             */
            execute_overweight: TxDescriptor<Anonymize<Ifhnflnkf9f278>>;
        },
        {
            /**
             *Message discarded due to an error in the `MessageProcessor` (usually a format error).
             */
            ProcessingFailed: PlainDescriptor<Anonymize<I6ian27okrbc15>>;
            /**
             *Message is processed.
             */
            Processed: PlainDescriptor<Anonymize<I74b8cu68dfbfr>>;
            /**
             *Message placed in overweight queue.
             */
            OverweightEnqueued: PlainDescriptor<Anonymize<Iacc6dee8ffsrh>>;
            /**
             *This page was reaped.
             */
            PageReaped: PlainDescriptor<Anonymize<Ielsom2b1kkdm6>>;
        },
        {
            /**
             *Page is not reapable because it has items remaining to be processed and is not old
             *enough.
             */
            NotReapable: PlainDescriptor<undefined>;
            /**
             *Page to be reaped does not exist.
             */
            NoPage: PlainDescriptor<undefined>;
            /**
             *The referenced message could not be found.
             */
            NoMessage: PlainDescriptor<undefined>;
            /**
             *The message was already processed and cannot be processed again.
             */
            AlreadyProcessed: PlainDescriptor<undefined>;
            /**
             *The message is queued for future execution.
             */
            Queued: PlainDescriptor<undefined>;
            /**
             *There is temporarily not enough weight to continue servicing messages.
             */
            InsufficientWeight: PlainDescriptor<undefined>;
            /**
             *This message is temporarily unprocessable.
             *
             *Such errors are expected, but not guaranteed, to resolve themselves eventually through
             *retrying.
             */
            TemporarilyUnprocessable: PlainDescriptor<undefined>;
            /**
             *The queue is paused and no message can be executed from it.
             *
             *This can change at any time and may resolve in the future by re-trying.
             */
            QueuePaused: PlainDescriptor<undefined>;
        },
        {
            /**
             * The size of the page; this implies the maximum message size which can be sent.
             *
             * A good value depends on the expected message sizes, their weights, the weight that is
             * available for processing them and the maximal needed message size. The maximal message
             * size is slightly lower than this as defined by [`MaxMessageLenOf`].
             */
            HeapSize: PlainDescriptor<number>;
            /**
             * The maximum number of stale pages (i.e. of overweight messages) allowed before culling
             * can happen. Once there are more stale pages than this, then historical pages may be
             * dropped, even if they contain unprocessed overweight messages.
             */
            MaxStale: PlainDescriptor<number>;
            /**
             * The amount of weight (if any) which should be provided to the message queue for
             * servicing enqueued items.
             *
             * This may be legitimately `None` in the case that you will call
             * `ServiceQueues::service_queues` manually.
             */
            ServiceWeight: PlainDescriptor<Anonymize<Iasb8k6ash5mjn>>;
        }
    ];
    AssetRate: [
        {
            /**
             * Maps an asset to its fixed point representation in the native balance.
             *
             * E.g. `native_amount = asset_amount * ConversionRateToNative::<T>::get(asset_kind)`
             */
            ConversionRateToNative: StorageDescriptor<[Key: Anonymize<I32r9skkupsthv>], bigint, true>;
        },
        {
            /**
             *See [`Pallet::create`].
             */
            create: TxDescriptor<Anonymize<I16soggnee6qrb>>;
            /**
             *See [`Pallet::update`].
             */
            update: TxDescriptor<Anonymize<I16soggnee6qrb>>;
            /**
             *See [`Pallet::remove`].
             */
            remove: TxDescriptor<Anonymize<Ifvnf1s3g2lg8u>>;
        },
        {
            /**
            
             */
            AssetRateCreated: PlainDescriptor<Anonymize<I16soggnee6qrb>>;
            /**
            
             */
            AssetRateRemoved: PlainDescriptor<Anonymize<Ifvnf1s3g2lg8u>>;
            /**
            
             */
            AssetRateUpdated: PlainDescriptor<Anonymize<Iedcb9b2srjfp0>>;
        },
        {
            /**
             *The given asset ID is unknown.
             */
            UnknownAssetKind: PlainDescriptor<undefined>;
            /**
             *The given asset ID already has an assigned conversion rate and cannot be re-created.
             */
            AlreadyExists: PlainDescriptor<undefined>;
        },
        {}
    ];
    Beefy: [
        {
            /**
             * The current authorities set
             */
            Authorities: StorageDescriptor<[], Anonymize<Ie5mvl0hn85mkc>, false>;
            /**
             * The current validator set id
             */
            ValidatorSetId: StorageDescriptor<[], bigint, false>;
            /**
             * Authorities set scheduled to be used with the next session
             */
            NextAuthorities: StorageDescriptor<[], Anonymize<Ie5mvl0hn85mkc>, false>;
            /**
             * A mapping from BEEFY set ID to the index of the *most recent* session for which its
             * members were responsible.
             *
             * This is only used for validating equivocation proofs. An equivocation proof must
             * contains a key-ownership proof for a given session, therefore we need a way to tie
             * together sessions and BEEFY set ids, i.e. we need to validate that a validator
             * was the owner of a given key on a given session, and what the active set ID was
             * during that session.
             *
             * TWOX-NOTE: `ValidatorSetId` is not under user control.
             */
            SetIdSession: StorageDescriptor<[Key: bigint], number, true>;
            /**
             * Block number where BEEFY consensus is enabled/started.
             * By changing this (through privileged `set_new_genesis()`), BEEFY consensus is effectively
             * restarted from the newly set block number.
             */
            GenesisBlock: StorageDescriptor<[], Anonymize<I4arjljr6dpflb>, false>;
        },
        {
            /**
             *See [`Pallet::report_equivocation`].
             */
            report_equivocation: TxDescriptor<Anonymize<I894urueu7skf3>>;
            /**
             *See [`Pallet::report_equivocation_unsigned`].
             */
            report_equivocation_unsigned: TxDescriptor<Anonymize<I894urueu7skf3>>;
            /**
             *See [`Pallet::set_new_genesis`].
             */
            set_new_genesis: TxDescriptor<Anonymize<Iemqna2uucuei9>>;
        },
        {},
        {
            /**
             *A key ownership proof provided as part of an equivocation report is invalid.
             */
            InvalidKeyOwnershipProof: PlainDescriptor<undefined>;
            /**
             *An equivocation proof provided as part of an equivocation report is invalid.
             */
            InvalidEquivocationProof: PlainDescriptor<undefined>;
            /**
             *A given equivocation report is valid but already previously reported.
             */
            DuplicateOffenceReport: PlainDescriptor<undefined>;
            /**
             *Submitted configuration is invalid.
             */
            InvalidConfiguration: PlainDescriptor<undefined>;
        },
        {
            /**
             * The maximum number of authorities that can be added.
             */
            MaxAuthorities: PlainDescriptor<number>;
            /**
             * The maximum number of nominators for each validator.
             */
            MaxNominators: PlainDescriptor<number>;
            /**
             * The maximum number of entries to keep in the set id to session index mapping.
             *
             * Since the `SetIdSession` map is only used for validating equivocations this
             * value should relate to the bonding duration of whatever staking system is
             * being used (if any). If equivocation handling is not enabled then this value
             * can be zero.
             */
            MaxSetIdSessionEntries: PlainDescriptor<bigint>;
        }
    ];
    Mmr: [
        {
            /**
             * Latest MMR Root hash.
             */
            RootHash: StorageDescriptor<[], Binary, false>;
            /**
             * Current size of the MMR (number of leaves).
             */
            NumberOfLeaves: StorageDescriptor<[], bigint, false>;
            /**
             * Hashes of the nodes in the MMR.
             *
             * Note this collection only contains MMR peaks, the inner nodes (and leaves)
             * are pruned and only stored in the Offchain DB.
             */
            Nodes: StorageDescriptor<[Key: bigint], Binary, true>;
        },
        {},
        {},
        {},
        {}
    ];
    BeefyMmrLeaf: [
        {
            /**
             * Details of current BEEFY authority set.
             */
            BeefyAuthorities: StorageDescriptor<[], Anonymize<I3qm5u05tioq05>, false>;
            /**
             * Details of next BEEFY authority set.
             *
             * This storage entry is used as cache for calls to `update_beefy_next_authority_set`.
             */
            BeefyNextAuthorities: StorageDescriptor<[], Anonymize<I3qm5u05tioq05>, false>;
        },
        {},
        {},
        {},
        {}
    ];
};
type IRuntimeCalls = {
    /**
     * The `Core` runtime api that every Substrate runtime needs to implement.
     */
    Core: {
        /**
         * Returns the version of the runtime.
         */
        version: RuntimeDescriptor<[], Anonymize<Ib5fo0fakl8rog>>;
        /**
         * Execute the given block.
         */
        execute_block: RuntimeDescriptor<[block: Anonymize<Ia4jqf401148a4>], undefined>;
        /**
         * Initialize a block with the given header.
         */
        initialize_block: RuntimeDescriptor<[header: Anonymize<I6t1nedlt7mobn>], undefined>;
    };
    /**
     * The `Metadata` api trait that returns metadata for the runtime.
     */
    Metadata: {
        /**
         * Returns the metadata of a runtime.
         */
        metadata: RuntimeDescriptor<[], Binary>;
        /**
         * Returns the metadata at a given version.
         *
         * If the given `version` isn't supported, this will return `None`.
         * Use [`Self::metadata_versions`] to find out about supported metadata version of the runtime.
         */
        metadata_at_version: RuntimeDescriptor<[version: number], Anonymize<Iabpgqcjikia83>>;
        /**
         * Returns the supported metadata versions.
         *
         * This can be used to call `metadata_at_version`.
         */
        metadata_versions: RuntimeDescriptor<[], Anonymize<Icgljjb6j82uhn>>;
    };
    /**
     * The `BlockBuilder` api trait that provides the required functionality for building a block.
     */
    BlockBuilder: {
        /**
         * Apply the given extrinsic.
         *
         * Returns an inclusion outcome which specifies if this extrinsic is included in
         * this block or not.
         */
        apply_extrinsic: RuntimeDescriptor<[extrinsic: Binary], Anonymize<I132412t2eshc6>>;
        /**
         * Finish the current block.
         */
        finalize_block: RuntimeDescriptor<[], Anonymize<I6t1nedlt7mobn>>;
        /**
         * Generate inherent extrinsics. The inherent data will vary from chain to chain.
         */
        inherent_extrinsics: RuntimeDescriptor<[inherent: Anonymize<If39abi8floaaf>], Anonymize<Itom7fk49o0c9>>;
        /**
         * Check that the inherents are valid. The inherent data will vary from chain to chain.
         */
        check_inherents: RuntimeDescriptor<[block: Anonymize<Ia4jqf401148a4>, data: Anonymize<If39abi8floaaf>], Anonymize<Ibcdj0j79gq1uo>>;
    };
    /**
     * Runtime api for accessing information about nomination pools.
     */
    NominationPoolsApi: {
        /**
         * Returns the pending rewards for the member that the AccountId was given for.
         */
        pending_rewards: RuntimeDescriptor<[who: SS58String], bigint>;
        /**
         * Returns the equivalent balance of `points` for a given pool.
         */
        points_to_balance: RuntimeDescriptor<[pool_id: number, points: bigint], bigint>;
        /**
         * Returns the equivalent points of `new_funds` for a given pool.
         */
        balance_to_points: RuntimeDescriptor<[pool_id: number, new_funds: bigint], bigint>;
    };
    /**
    
     */
    StakingApi: {
        /**
         * Returns the nominations quota for a nominator with a given balance.
         */
        nominations_quota: RuntimeDescriptor<[balance: bigint], number>;
    };
    /**
     * The `TaggedTransactionQueue` api trait for interfering with the transaction queue.
     */
    TaggedTransactionQueue: {
        /**
         * Validate the transaction.
         *
         * This method is invoked by the transaction pool to learn details about given transaction.
         * The implementation should make sure to verify the correctness of the transaction
         * against current state. The given `block_hash` corresponds to the hash of the block
         * that is used as current state.
         *
         * Note that this call may be performed by the pool multiple times and transactions
         * might be verified in any possible order.
         */
        validate_transaction: RuntimeDescriptor<[source: TransactionValidityTransactionSource, tx: Binary, block_hash: Binary], Anonymize<I6d9lhhdri071p>>;
    };
    /**
     * The offchain worker api.
     */
    OffchainWorkerApi: {
        /**
         * Starts the off-chain task for given block header.
         */
        offchain_worker: RuntimeDescriptor<[header: Anonymize<I6t1nedlt7mobn>], undefined>;
    };
    /**
     * The API for querying the state of parachains on-chain.
     */
    ParachainHost: {
        /**
         * Get the current validators.
         */
        validators: RuntimeDescriptor<[], Anonymize<Idhnf6rtqoslea>>;
        /**
         * Returns the validator groups and rotation info localized based on the hypothetical child
         *  of a block whose state  this is invoked on. Note that `now` in the `GroupRotationInfo`
         * should be the successor of the number of the block.
         */
        validator_groups: RuntimeDescriptor<[], Anonymize<I5985kfq7sspta>>;
        /**
         * Yields information on all availability cores as relevant to the child block.
         * Cores are either free or occupied. Free cores can have paras assigned to them.
         */
        availability_cores: RuntimeDescriptor<[], Anonymize<I8a7gsn4nh0gne>>;
        /**
         * Yields the persisted validation data for the given `ParaId` along with an assumption that
         * should be used if the para currently occupies a core.
         *
         * Returns `None` if either the para is not registered or the assumption is `Freed`
         * and the para already occupies a core.
         */
        persisted_validation_data: RuntimeDescriptor<[para_id: number, assumption: PolkadotPrimitivesV5OccupiedCoreAssumption], Anonymize<I3gq2gui038qt>>;
        /**
         * Returns the persisted validation data for the given `ParaId` along with the corresponding
         * validation code hash. Instead of accepting assumption about the para, matches the validation
         * data hash against an expected one and yields `None` if they're not equal.
         */
        assumed_validation_data: RuntimeDescriptor<[para_id: number, expected_persisted_validation_data_hash: Binary], Anonymize<Ic7as9gfl5utn9>>;
        /**
         * Checks if the given validation outputs pass the acceptance criteria.
         */
        check_validation_outputs: RuntimeDescriptor<[para_id: number, outputs: Anonymize<Ic1d4u2opv3fst>], boolean>;
        /**
         * Returns the session index expected at a child of the block.
         *
         * This can be used to instantiate a `SigningContext`.
         */
        session_index_for_child: RuntimeDescriptor<[], number>;
        /**
         * Fetch the validation code used by a para, making the given `OccupiedCoreAssumption`.
         *
         * Returns `None` if either the para is not registered or the assumption is `Freed`
         * and the para already occupies a core.
         */
        validation_code: RuntimeDescriptor<[para_id: number, assumption: PolkadotPrimitivesV5OccupiedCoreAssumption], Anonymize<Iabpgqcjikia83>>;
        /**
         * Get the receipt of a candidate pending availability. This returns `Some` for any paras
         * assigned to occupied cores in `availability_cores` and `None` otherwise.
         */
        candidate_pending_availability: RuntimeDescriptor<[para_id: number], Anonymize<I2914et6njplkd>>;
        /**
         * Get a vector of events concerning candidates that occurred within a block.
         */
        candidate_events: RuntimeDescriptor<[], Anonymize<Ianqtalutublq5>>;
        /**
         * Get all the pending inbound messages in the downward message queue for a para.
         */
        dmq_contents: RuntimeDescriptor<[recipient: number], Anonymize<I6ljjd4b5fa4ov>>;
        /**
         * Get the contents of all channels addressed to the given recipient. Channels that have no
         * messages in them are also included.
         */
        inbound_hrmp_channels_contents: RuntimeDescriptor<[recipient: number], Anonymize<I2pf0b05mc7sdr>>;
        /**
         * Get the validation code from its hash.
         */
        validation_code_by_hash: RuntimeDescriptor<[hash: Binary], Anonymize<Iabpgqcjikia83>>;
        /**
         * Scrape dispute relevant from on-chain, backing votes and resolved disputes.
         */
        on_chain_votes: RuntimeDescriptor<[], Anonymize<Ibfq7qcjfd788c>>;
        /**
         * Get the session info for the given session, if stored.
         *
         * NOTE: This function is only available since parachain host version 2.
         */
        session_info: RuntimeDescriptor<[index: number], Anonymize<I5537sfe0t0708>>;
        /**
         * Submits a PVF pre-checking statement into the transaction pool.
         *
         * NOTE: This function is only available since parachain host version 2.
         */
        submit_pvf_check_statement: RuntimeDescriptor<[stmt: Anonymize<I3h1ccufdk38ej>, signature: Binary], undefined>;
        /**
         * Returns code hashes of PVFs that require pre-checking by validators in the active set.
         *
         * NOTE: This function is only available since parachain host version 2.
         */
        pvfs_require_precheck: RuntimeDescriptor<[], Anonymize<Idhnf6rtqoslea>>;
        /**
         * Fetch the hash of the validation code used by a para, making the given `OccupiedCoreAssumption`.
         *
         * NOTE: This function is only available since parachain host version 2.
         */
        validation_code_hash: RuntimeDescriptor<[para_id: number, assumption: PolkadotPrimitivesV5OccupiedCoreAssumption], Anonymize<I17k3ujudqd5df>>;
        /**
         * Returns all onchain disputes.
         */
        disputes: RuntimeDescriptor<[], Anonymize<I8bqhj6psoqsin>>;
        /**
         * Returns execution parameters for the session.
         */
        session_executor_params: RuntimeDescriptor<[session_index: number], Anonymize<I1b0210m3f090j>>;
        /**
         * Returns a list of validators that lost a past session dispute and need to be slashed.
         * NOTE: This function is only available since parachain host version 5.
         */
        unapplied_slashes: RuntimeDescriptor<[], Anonymize<Icqsglphsrpv5>>;
        /**
         * Returns a merkle proof of a validator session key.
         * NOTE: This function is only available since parachain host version 5.
         */
        key_ownership_proof: RuntimeDescriptor<[validator_id: Binary], Anonymize<Iabpgqcjikia83>>;
        /**
         * Submit an unsigned extrinsic to slash validators who lost a dispute about
         * a candidate of a past session.
         * NOTE: This function is only available since parachain host version 5.
         */
        submit_report_dispute_lost: RuntimeDescriptor<[dispute_proof: Anonymize<Iag14tqe65tvpf>, key_ownership_proof: Binary], boolean>;
        /**
         * Get the minimum number of backing votes for a parachain candidate.
         * This is a staging method! Do not use on production runtimes!
         */
        minimum_backing_votes: RuntimeDescriptor<[], number>;
        /**
         * Returns the state of parachain backing for a given para.
         */
        para_backing_state: RuntimeDescriptor<[_: number], Anonymize<I4gc64ora0pbbf>>;
        /**
         * Returns candidate's acceptance limitations for asynchronous backing for a relay parent.
         */
        async_backing_params: RuntimeDescriptor<[], Anonymize<Iavuvfkop6318c>>;
        /**
         * Returns a list of all disabled validators at the given block.
         */
        disabled_validators: RuntimeDescriptor<[], Anonymize<Icgljjb6j82uhn>>;
    };
    /**
     * API necessary for BEEFY voters.
     */
    BeefyApi: {
        /**
         * Return the block number where BEEFY consensus is enabled/started
         */
        beefy_genesis: RuntimeDescriptor<[], Anonymize<I4arjljr6dpflb>>;
        /**
         * Return the current active BEEFY validator set
         */
        validator_set: RuntimeDescriptor<[], Anonymize<I71rr2d0kb0iu3>>;
        /**
         * Submits an unsigned extrinsic to report an equivocation. The caller
         * must provide the equivocation proof and a key ownership proof
         * (should be obtained using `generate_key_ownership_proof`). The
         * extrinsic will be unsigned and should only be accepted for local
         * authorship (not to be broadcast to the network). This method returns
         * `None` when creation of the extrinsic fails, e.g. if equivocation
         * reporting is disabled for the given runtime (i.e. this method is
         * hardcoded to return `None`). Only useful in an offchain context.
         */
        submit_report_equivocation_unsigned_extrinsic: RuntimeDescriptor<[equivocation_proof: Anonymize<I6lgkrki6lhal>, key_owner_proof: Binary], boolean>;
        /**
         * Generates a proof of key ownership for the given authority in the
         * given set. An example usage of this module is coupled with the
         * session historical module to prove that a given authority key is
         * tied to a given staking identity during a specific session. Proofs
         * of key ownership are necessary for submitting equivocation reports.
         * NOTE: even though the API takes a `set_id` as parameter the current
         * implementations ignores this parameter and instead relies on this
         * method being called at the correct block height, i.e. any point at
         * which the given set id is live on-chain. Future implementations will
         * instead use indexed data through an offchain worker, not requiring
         * older states to be available.
         */
        generate_key_ownership_proof: RuntimeDescriptor<[set_id: bigint, authority_id: Binary], Anonymize<Iabpgqcjikia83>>;
    };
    /**
     * API to interact with MMR pallet.
     */
    MmrApi: {
        /**
         * Return the on-chain MMR root hash.
         */
        mmr_root: RuntimeDescriptor<[], Anonymize<I7m8g2583l7nbe>>;
        /**
         * Return the number of MMR blocks in the chain.
         */
        mmr_leaf_count: RuntimeDescriptor<[], Anonymize<I256gkugrgtccq>>;
        /**
         * Generate MMR proof for a series of block numbers. If `best_known_block_number = Some(n)`,
         * use historical MMR state at given block height `n`. Else, use current MMR state.
         */
        generate_proof: RuntimeDescriptor<[block_numbers: Anonymize<Icgljjb6j82uhn>, best_known_block_number: Anonymize<I4arjljr6dpflb>], Anonymize<I32e5ntud5fl8i>>;
        /**
         * Verify MMR proof against on-chain MMR for a batch of leaves.
         *
         * Note this function will use on-chain MMR root hash and check if the proof matches the hash.
         * Note, the leaves should be sorted such that corresponding leaves and leaf indices have the
         * same position in both the `leaves` vector and the `leaf_indices` vector contained in the [Proof]
         */
        verify_proof: RuntimeDescriptor<[leaves: Anonymize<Itom7fk49o0c9>, proof: Anonymize<I2ij509mgq3dve>], Anonymize<I9lnenfklcdre>>;
        /**
         * Verify MMR proof against given root hash for a batch of leaves.
         *
         * Note this function does not require any on-chain storage - the
         * proof is verified against given MMR root hash.
         *
         * Note, the leaves should be sorted such that corresponding leaves and leaf indices have the
         * same position in both the `leaves` vector and the `leaf_indices` vector contained in the [Proof]
         */
        verify_proof_stateless: RuntimeDescriptor<[root: Binary, leaves: Anonymize<Itom7fk49o0c9>, proof: Anonymize<I2ij509mgq3dve>], Anonymize<I9lnenfklcdre>>;
    };
    /**
     * API useful for BEEFY light clients.
     */
    BeefyMmrApi: {
        /**
         * Return the currently active BEEFY authority set proof.
         */
        authority_set_proof: RuntimeDescriptor<[], Anonymize<I3qm5u05tioq05>>;
        /**
         * Return the next/queued BEEFY authority set proof.
         */
        next_authority_set_proof: RuntimeDescriptor<[], Anonymize<I3qm5u05tioq05>>;
    };
    /**
     * APIs for integrating the GRANDPA finality gadget into runtimes.
     * This should be implemented on the runtime side.
     *
     * This is primarily used for negotiating authority-set changes for the
     * gadget. GRANDPA uses a signaling model of changing authority sets:
     * changes should be signaled with a delay of N blocks, and then automatically
     * applied in the runtime after those N blocks have passed.
     *
     * The consensus protocol will coordinate the handoff externally.
     */
    GrandpaApi: {
        /**
         * Get the current GRANDPA authorities and weights. This should not change except
         * for when changes are scheduled and the corresponding delay has passed.
         *
         * When called at block B, it will return the set of authorities that should be
         * used to finalize descendants of this block (B+1, B+2, ...). The block B itself
         * is finalized by the authorities from block B-1.
         */
        grandpa_authorities: RuntimeDescriptor<[], Anonymize<I2qinct8jq4bqe>>;
        /**
         * Submits an unsigned extrinsic to report an equivocation. The caller
         * must provide the equivocation proof and a key ownership proof
         * (should be obtained using `generate_key_ownership_proof`). The
         * extrinsic will be unsigned and should only be accepted for local
         * authorship (not to be broadcast to the network). This method returns
         * `None` when creation of the extrinsic fails, e.g. if equivocation
         * reporting is disabled for the given runtime (i.e. this method is
         * hardcoded to return `None`). Only useful in an offchain context.
         */
        submit_report_equivocation_unsigned_extrinsic: RuntimeDescriptor<[equivocation_proof: Anonymize<I95fr9lj1pb8v8>, key_owner_proof: Binary], boolean>;
        /**
         * Generates a proof of key ownership for the given authority in the
         * given set. An example usage of this module is coupled with the
         * session historical module to prove that a given authority key is
         * tied to a given staking identity during a specific session. Proofs
         * of key ownership are necessary for submitting equivocation reports.
         * NOTE: even though the API takes a `set_id` as parameter the current
         * implementations ignore this parameter and instead rely on this
         * method being called at the correct block height, i.e. any point at
         * which the given set id is live on-chain. Future implementations will
         * instead use indexed data through an offchain worker, not requiring
         * older states to be available.
         */
        generate_key_ownership_proof: RuntimeDescriptor<[set_id: bigint, authority_id: Binary], Anonymize<Iabpgqcjikia83>>;
        /**
         * Get current GRANDPA authority set id.
         */
        current_set_id: RuntimeDescriptor<[], bigint>;
    };
    /**
     * API necessary for block authorship with BABE.
     */
    BabeApi: {
        /**
         * Return the configuration for BABE.
         */
        configuration: RuntimeDescriptor<[], Anonymize<Iap4lrotpgmqpv>>;
        /**
         * Returns the slot that started the current epoch.
         */
        current_epoch_start: RuntimeDescriptor<[], bigint>;
        /**
         * Returns information regarding the current epoch.
         */
        current_epoch: RuntimeDescriptor<[], Anonymize<I6sbl80o3jmgfd>>;
        /**
         * Returns information regarding the next epoch (which was already
         * previously announced).
         */
        next_epoch: RuntimeDescriptor<[], Anonymize<I6sbl80o3jmgfd>>;
        /**
         * Generates a proof of key ownership for the given authority in the
         * current epoch. An example usage of this module is coupled with the
         * session historical module to prove that a given authority key is
         * tied to a given staking identity during a specific session. Proofs
         * of key ownership are necessary for submitting equivocation reports.
         * NOTE: even though the API takes a `slot` as parameter the current
         * implementations ignores this parameter and instead relies on this
         * method being called at the correct block height, i.e. any point at
         * which the epoch for the given slot is live on-chain. Future
         * implementations will instead use indexed data through an offchain
         * worker, not requiring older states to be available.
         */
        generate_key_ownership_proof: RuntimeDescriptor<[slot: bigint, authority_id: Binary], Anonymize<Iabpgqcjikia83>>;
        /**
         * Submits an unsigned extrinsic to report an equivocation. The caller
         * must provide the equivocation proof and a key ownership proof
         * (should be obtained using `generate_key_ownership_proof`). The
         * extrinsic will be unsigned and should only be accepted for local
         * authorship (not to be broadcast to the network). This method returns
         * `None` when creation of the extrinsic fails, e.g. if equivocation
         * reporting is disabled for the given runtime (i.e. this method is
         * hardcoded to return `None`). Only useful in an offchain context.
         */
        submit_report_equivocation_unsigned_extrinsic: RuntimeDescriptor<[equivocation_proof: Anonymize<I7bek4s9acs8nl>, key_owner_proof: Binary], boolean>;
    };
    /**
     * The authority discovery api.
     *
     * This api is used by the `client/authority-discovery` module to retrieve identifiers
     * of the current and next authority set.
     */
    AuthorityDiscoveryApi: {
        /**
         * Retrieve authority identifiers of the current and next authority set.
         */
        authorities: RuntimeDescriptor<[], Anonymize<Idhnf6rtqoslea>>;
    };
    /**
     * Session keys runtime api.
     */
    SessionKeys: {
        /**
         * Generate a set of session keys with optionally using the given seed.
         * The keys should be stored within the keystore exposed via runtime
         * externalities.
         *
         * The seed needs to be a valid `utf8` string.
         *
         * Returns the concatenated SCALE encoded public keys.
         */
        generate_session_keys: RuntimeDescriptor<[seed: Anonymize<Iabpgqcjikia83>], Binary>;
        /**
         * Decode the given public session keys.
         *
         * Returns the list of public raw public keys + key type.
         */
        decode_session_keys: RuntimeDescriptor<[encoded: Binary], Anonymize<I96ok5o1k21bpi>>;
    };
    /**
     * The API to query account nonce.
     */
    AccountNonceApi: {
        /**
         * Get current account nonce of given `AccountId`.
         */
        account_nonce: RuntimeDescriptor<[account: SS58String], number>;
    };
    /**
    
     */
    TransactionPaymentApi: {
        /**
        
         */
        query_info: RuntimeDescriptor<[uxt: Binary, len: number], Anonymize<I5r4utvvlnltpd>>;
        /**
        
         */
        query_fee_details: RuntimeDescriptor<[uxt: Binary, len: number], Anonymize<Iei2mvq0mjvt81>>;
        /**
        
         */
        query_weight_to_fee: RuntimeDescriptor<[weight: Anonymize<I4q39t5hn830vp>], bigint>;
        /**
        
         */
        query_length_to_fee: RuntimeDescriptor<[length: number], bigint>;
    };
    /**
    
     */
    TransactionPaymentCallApi: {
        /**
         * Query information of a dispatch class, weight, and fee of a given encoded `Call`.
         */
        query_call_info: RuntimeDescriptor<[call: Anonymize<I8e6un4uk1q07c>, len: number], Anonymize<I5r4utvvlnltpd>>;
        /**
         * Query fee details of a given encoded `Call`.
         */
        query_call_fee_details: RuntimeDescriptor<[call: Anonymize<I8e6un4uk1q07c>, len: number], Anonymize<Iei2mvq0mjvt81>>;
        /**
         * Query the output of the current `WeightToFee` given some input.
         */
        query_weight_to_fee: RuntimeDescriptor<[weight: Anonymize<I4q39t5hn830vp>], bigint>;
        /**
         * Query the output of the current `LengthToFee` given some input.
         */
        query_length_to_fee: RuntimeDescriptor<[length: number], bigint>;
    };
    /**
     * API to interact with GenesisConfig for the runtime
     */
    GenesisBuilder: {
        /**
         * Creates the default `GenesisConfig` and returns it as a JSON blob.
         *
         * This function instantiates the default `GenesisConfig` struct for the runtime and serializes it into a JSON
         * blob. It returns a `Vec<u8>` containing the JSON representation of the default `GenesisConfig`.
         */
        create_default_config: RuntimeDescriptor<[], Binary>;
        /**
         * Build `GenesisConfig` from a JSON blob not using any defaults and store it in the storage.
         *
         * This function deserializes the full `GenesisConfig` from the given JSON blob and puts it into the storage.
         * If the provided JSON blob is incorrect or incomplete or the deserialization fails, an error is returned.
         * It is recommended to log any errors encountered during the process.
         *
         * Please note that provided json blob must contain all `GenesisConfig` fields, no defaults will be used.
         */
        build_config: RuntimeDescriptor<[json: Binary], Anonymize<I9q9lvv0h98nhk>>;
    };
};
type IAsset = AssetDescriptor<void>;
type IDescriptors = {
    pallets: IPallets;
    apis: IRuntimeCalls;
    asset: IAsset;
    checksums: Promise<string[]>;
};
declare const _allDescriptors: IDescriptors;
export default _allDescriptors;
export type PolkadotQueries = QueryFromDescriptors<IDescriptors>;
export type PolkadotCalls = TxFromDescriptors<IDescriptors>;
export type PolkadotEvents = EventsFromDescriptors<IDescriptors>;
export type PolkadotErrors = ErrorsFromDescriptors<IDescriptors>;
export type PolkadotConstants = ConstFromDescriptors<IDescriptors>;
export * from './public-types';
